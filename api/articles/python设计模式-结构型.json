{"title":"Python设计模式-结构型","slug":"python设计模式-结构型","date":"2022-06-01T15:33:00.000Z","updated":"2022-09-30T06:56:37.181Z","comments":true,"path":"api/articles/python设计模式-结构型.json","excerpt":null,"covers":["https://oceaneyes.top/img/zhishigroup.jpg","https://oceaneyes.top/img/alipay.jpg","https://oceaneyes.top/img/wechatpay.jpg"],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"python设计模式-结构型适配器模式装饰者模式代理模式组合模式外观模式\">Python设计模式-结构型：适配器模式,装饰者模式,代理模式,组合模式,外观模式</h2>\n<ul>\n<li>适配器模式定义及简单实现案例</li>\n<li>装饰者模式定义及简单实现案例</li>\n<li>代理模式定义及简单实现案例</li>\n<li>组合模式定义及简单实现案例</li>\n<li>外观模式定义及简单实现案例</li>\n</ul>\n<h3 id=\"适配器模式-adapter\">适配器模式 adapter</h3>\n<p>电子产品的电源插头插在转换插头上，然后转换插头插上电源，电子产品就能正常工作了。这就是适配器模式</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\nclass OldCourse(object):\n    &quot;&quot;&quot;\n    老的课程类\n    &quot;&quot;&quot;\n\n    def show(self):\n        &quot;&quot;&quot;\n        显示关于本课程的所有信息\n        &quot;&quot;&quot;\n        print(&quot;show description&quot;)\n        print(&quot;show teacher of course&quot;)\n        print(&quot;show labs&quot;)\n\n\nclass Page(object):\n    &quot;&quot;&quot;\n    使用课程对象的客户端\n    &quot;&quot;&quot;\n\n    def __init__(self, course):\n        self.course = course\n\n    def render(self):\n        self.course.show()\n\n\nclass NewCourse(object):\n    &quot;&quot;&quot;\n    新的课程类, 为了模块化显示课程信息，实现了新的课程类\n    &quot;&quot;&quot;\n    def show_desc(self):\n        &quot;&quot;&quot;\n        显示描述信息\n        &quot;&quot;&quot;\n        print(&quot;show description&quot;)\n\n    def show_teacher(self):\n        &quot;&quot;&quot;\n        显示老师信息\n        &quot;&quot;&quot;\n        print(&quot;show teacher of course&quot;)\n\n    def show_labs(self):\n        &quot;&quot;&quot;\n        显示实验\n        &quot;&quot;&quot;\n        print(&quot;show labs&quot;)\n\n\nclass Adapter(object):\n    &quot;&quot;&quot;\n    适配器, 尽管实现了新的课程类，但是在很多代码中还是需要使用 OldCourse.show() 方法\n    &quot;&quot;&quot;\n\n    def __init__(self, course):\n        self.course = course\n\n    def show(self):\n        &quot;&quot;&quot;\n        适配方法，调用真正的操作\n        &quot;&quot;&quot;\n        self.course.show_desc()\n        self.course.show_teacher()\n        self.course.show_labs()\n\n\nif __name__ == &#39;__main__&#39;:\n    old_course = OldCourse()\n    page = Page(old_course)\n    page.render()\n    print(&quot;&quot;)\n    new_course = NewCourse()\n    # 新课程类没有 show 方法，我们需要使用适配器进行适配\n    adapter = Adapter(new_course)\n    page = Page(adapter)\n    page.render()</code></pre>\n<p><strong>适配器模式就是把一个类的接口变换成客户端所期待的另一种接口，使原本因接口不兼容而无法在一起工作的两个类能够在一起工作。</strong></p>\n<h3 id=\"装饰者模式-decorator\">装饰者模式 Decorator</h3>\n<p>装饰者模式能动态的给对象添加行为。如果你对 Flask\n比较熟悉的话，应该知道在使用 Flask-Login 的时候可以使用 login_required\n装饰器包装一个需要用户登录访问的view</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\nfrom functools import wraps\n\nHOST_DOCKER = 0\n\n\ndef docker_host_required(f):\n    &quot;&quot;&quot;\n    装饰器，必须要求 host 类型是 HOST_DOCKER\n    &quot;&quot;&quot;\n    @wraps(f)\n    def wrapper(*args, **kwargs):\n        if args[0].type != HOST_DOCKER:\n            raise Exception(&quot;Not docker host&quot;)\n        else:\n            return f(*args, **kwargs)\n    return wrapper\n\n\nclass Host(object):\n    &quot;&quot;&quot;\n    host 类\n    &quot;&quot;&quot;\n\n    def __init__(self, type):\n        self.type = type\n\n    # 装饰这一方法\n    @docker_host_required\n    def create_container(self):\n        print(&quot;create container&quot;)\n\n\nif __name__ == &#39;__main__&#39;:\n    # 初始化 Host\n    host = Host(HOST_DOCKER)\n    host.create_container()\n    print(&quot;&quot;)\n    # 再次初始化 Host\n    host = Host(1)\n    host.create_container()</code></pre>\n<p>在上面的代码中，Host有一个方法Host.create_container，只有当Host实例的类型是DOCKER_HOST的时候才能执行该方法。为了加上这一行为，我们使用了装饰者模式。可以看出使用装饰者模式，我们可以动态改变类的行为，同时能提高代码复用性，因为任何类型为HOST_DOCKER的Host都可以使用该装饰器。另外要说明下：为了更好的实现装饰器，我们使用functools.wrap函数。</p>\n<h3 id=\"代理模式-proxy\">代理模式 proxy</h3>\n<p>所谓代理模式就是给一个对象提供一个代理，并由代理对象控制对原对象的访问。通过代理，我们可以对访问做一些控制。在开发网站的过程中，针对一些频繁访问的资源，我们会使用缓存。</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\nfrom time import sleep\n\n\nclass Redis(object):\n    &quot;&quot;&quot;\n    用于模拟 redis 服务\n    &quot;&quot;&quot;\n\n    def __init__(self):\n        &quot;&quot;&quot;\n        使用字典存储数据\n        &quot;&quot;&quot;\n        self.cache = dict()\n\n    def get(self, key):\n        &quot;&quot;&quot;\n        获取数据\n        &quot;&quot;&quot;\n        return self.cache.get(key)\n\n    def set(self, key, value):\n        &quot;&quot;&quot;\n        设置数据\n        &quot;&quot;&quot;\n        self.cache[key] = value\n\n\nclass Image(object):\n    &quot;&quot;&quot;\n    图片对象，图片存在七牛云存储中，我们只保存了一个地址\n    &quot;&quot;&quot;\n\n    def __init__(self, name):\n        self.name = name\n\n    @property\n    def url(self):\n        sleep(2)\n        return &quot;https://dn-syl-static.qbox.me/img/logo-transparent.png&quot;\n\n\nclass Page(object):\n    &quot;&quot;&quot;\n    用于显示图片\n    &quot;&quot;&quot;\n\n    def __init__(self, image):\n        &quot;&quot;&quot;\n        需要图片进行初始化\n        &quot;&quot;&quot;\n        self.image = image\n\n    def render(self):\n        &quot;&quot;&quot;\n        显示图片\n        &quot;&quot;&quot;\n        print(self.image.url)\n\n\nredis = Redis()\n\n\nclass ImageProxy(object):\n    &quot;&quot;&quot;\n    图片代理，首次访问会从真正的图片对象中获取地址，以后都从 Redis 缓存中获取\n    &quot;&quot;&quot;\n\n    def __init__(self, image):\n        self.image = image\n\n    @property\n    def url(self):\n        addr = redis.get(self.image.name)\n        if not addr:\n            addr = self.image.url\n            print(&quot;Set url in redis cache!&quot;)\n            redis.set(self.image.name, addr)\n        else:\n            print(&quot;Get url from redis cache!&quot;)\n        return addr\n\n\nif __name__ == &#39;__main__&#39;:\n    img = Image(name=&quot;logo&quot;)\n    proxy = ImageProxy(img)\n    page = Page(proxy)\n    # 首次访问\n    page.render()\n    print(&quot;&quot;)\n    # 第二次访问\n    page.render()</code></pre>\n<p>代理对象和真实的对象之间都实现了共同的接口，这使我们可以在不改变原接口情况下，使用真实对象的地方都可以使用代理对象。其次，代理对象在客户端和真实对象之间直接起到了中介作用，同时通过代理对象，我们可以在将客户请求传递给真实对象之前做一些必要的预处理。</p>\n<h3 id=\"组合模式-composite\">组合模式 composite</h3>\n<p>什么是组合模式？按照定义来说，组合模式是将对象组合成树形结构表示，使得客户端对单个对象和组合对象的使用具有一致性。组合模式的使用通常会生成一棵对象树，对象树中的叶子结点代表单个对象，其他节点代表组合对象。调用某一组合对象的方法，其实会迭代调用所有其叶子对象的方法。</p>\n<p>使用组合模式的经典例子是 Linux\n系统内的树形菜单和文件系统。在树形菜单中，每一项菜单可能是一个组合对象，其包含了菜单项和子菜单，这样就形成了一棵对象树。在文件系统中，叶子对象就是文件，而文件夹就是组合对象，文件夹可以包含文件夹和文件，同样又形成了一棵对象树。同样的例子还有员工和领导之间的关系</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\nimport abc\n\n\nclass Worker(object):\n    &quot;&quot;&quot;\n    员工抽象类\n    &quot;&quot;&quot;\n    __metaclass__ = abc.ABCMeta\n\n    def __init__(self, name):\n        self.name = name\n\n    @abc.abstractmethod\n    def work(self):\n        pass\n\n\nclass Employe(Worker):\n    &quot;&quot;&quot;\n    员工类\n    &quot;&quot;&quot;\n    __metaclass__ = abc.ABCMeta\n\n    def work(self):\n        print(&quot;Employ: %s start to work &quot; % self.name)\n\n\nclass Leader(Worker):\n    &quot;&quot;&quot;\n    领导类\n    &quot;&quot;&quot;\n\n    def __init__(self, name):\n        self.members = []\n        super(Leader, self).__init__(name)\n\n    def add_member(self, employe):\n        if employe not in self.members:\n            self.members.append(employe)\n\n    def remove_member(self, employe):\n        if employe in self.members:\n            self.members.remove(employe)\n\n    def work(self):\n        print(&quot;Leader: %s start to work&quot; % self.name)\n        for employe in self.members:\n            employe.work()\n\n\nif __name__ == &#39;__main__&#39;:\n    employe_1 = Employe(&quot;employe_1&quot;)\n    employe_2 = Employe(&quot;employe_2&quot;)\n    leader_1 = Leader(&quot;leader_1&quot;)\n    leader_1.add_member(employe_1)\n    leader_1.add_member(employe_2)\n\n    employe_3 = Employe(&quot;employe_3&quot;)\n    leader_2 = Leader(&quot;leader_2&quot;)\n    leader_2.add_member(employe_3)\n    leader_2.add_member(leader_1)\n\n    leader_2.work()</code></pre>\n<h3 id=\"外观模式-facade\">外观模式 facade</h3>\n<p>所谓外观模式，就是将各种子系统的复杂操作通过外观模式简化，让客户端使用起来更方便简洁。\n-\n比如你夏天晚上出门时，要关闭电灯，关闭电视机，关闭空调，如果有了一个总开关，通过它可以关闭电灯，电视机和空调，你出门的时候关闭总开关就行了。\n- 在这个例子中，你就是客户端，总开关就是外观模式的化身</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\n\nclass User(object):\n    &quot;&quot;&quot;\n    用户类\n    &quot;&quot;&quot;\n    def is_login(self):\n        return True\n\n    def has_privilege(self, privilege):\n        return True\n\n\nclass Course(object):\n    &quot;&quot;&quot;\n    课程类\n    &quot;&quot;&quot;\n    def can_be_learned(self):\n        return True\n\n\nclass Lab(object):\n    &quot;&quot;&quot;\n    实验类\n    &quot;&quot;&quot;\n    def can_be_started(self):\n        return True\n\n\nclass Client(object):\n    &quot;&quot;&quot;\n    客户类，用于开始一个实验\n    &quot;&quot;&quot;\n    def __init__(self, user, course, lab):\n        self.user = user\n        self.course = course\n        self.lab = lab\n\n    def start_lab(self):\n        &quot;&quot;&quot;\n        开始实验，需要一系列的判断：用户是否登录，课程是否可以学习，实验是否可以开始。判断非常繁琐！\n        &quot;&quot;&quot;\n        if self.user.is_login() and self.course.can_be_learned() and self.lab.can_be_started():\n            print(&quot;start lab&quot;)\n        else:\n            print(&quot;can not start lab&quot;)\n\n\nclass FacadeLab(object):\n    &quot;&quot;&quot;\n    新的Lab类，应用了面向对象模式\n    &quot;&quot;&quot;\n\n    def __init__(self, user, course, lab):\n        self.user = user\n        self.course = course\n        self.lab = lab\n\n    def can_be_started(self):\n        if self.user.is_login() and self.course.can_be_learned() and self.lab.can_be_started():\n            return True\n        else:\n            return False\n\n\nclass NewClient(object):\n    &quot;&quot;&quot;\n    新的客户类，使用外观模式\n    &quot;&quot;&quot;\n    def __init__(self, facade_lab):\n        self.lab = facade_lab\n\n    def start_lab(self):\n        &quot;&quot;&quot;\n        开始实验，只需要判断 FacadeLab 是否可以开始\n        &quot;&quot;&quot;\n        if self.lab.can_be_started:\n            print(&quot;start lab&quot;)\n        else:\n            print(&quot;can not start lab&quot;)\n\n\nif __name__ == &#39;__main__&#39;:\n    user = User()\n    course = Course()\n    lab = Lab()\n    client = Client(user, course, lab)\n    client.start_lab()\n\n    print(&quot;Use Facade Pattern:&quot;)\n    facade_lab = FacadeLab(user, course, lab)\n    facade_client = NewClient(facade_lab)\n    facade_client.start_lab()\n</code></pre>\n<p>外观模式的主要目的在于降低系统的复杂程度，在面向对象软件系统中，类与类之间的关系越多，不能表示系统设计得越好，反而表示系统中类之间的耦合度太大，这样的系统在维护和修改时都缺乏灵活性，因为一个类的改动会导致多个类发生变化，而外观模式的引入在很大程度上降低了类与类之间的耦合关系。引入外观模式之后，增加新的子系统或者移除子系统都非常方便，客户类无须进行修改（或者极少的修改），只需要在外观类中增加或移除对子系统的引用即可。</p>\n<hr>\n<h3 id=\"about-me\">About ME</h3>\n<h5 id=\"读书城南-在未来面前我们都是孩子\">👋 读书城南，🤔\n在未来面前，我们都是孩子～</h5>\n<ul>\n<li>📙\n一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~</li>\n</ul>\n<h5 id=\"social-media\">👋 Social Media</h5>\n<ul>\n<li><p>🛠️ Blog: <a href=\"http://oceaneyes.top\">http://oceaneyes.top</a></p></li>\n<li><p>⚡ PM导航: <a href=\"https://pmhub.oceangzy.top\">https://pmhub.oceangzy.top</a></p></li>\n<li><p>☘️ CNBLOG: <a href=\"https://www.cnblogs.com/oceaneyes-gzy/\">https://www.cnblogs.com/oceaneyes-gzy/</a></p></li>\n<li><p>🌱 AI PRJ自己部署的一些算法demo: <a href=\"http://ai.oceangzy.top/\">http://ai.oceangzy.top/</a></p></li>\n<li><p>📫 Email: 1450136519@qq.com</p></li>\n<li><p>💬 WeChat: <a href=\"https://oceaneyes.top/img/wechatqrcode.jpg\">OCEANGZY</a></p></li>\n<li><p>💬 公众号: <a href=\"https://oceaneyes.top/img/wechatgzh.jpeg\">UncleJoker-GZY</a></p></li>\n</ul>\n<h5 id=\"加入小组\">👋 加入小组~</h5>\n<p><img src=\"https://oceaneyes.top/img/zhishigroup.jpg\" title=\"加入组织\" alt width=\"240\"></p>\n<h5 id=\"感谢打赏\">👋 感谢打赏~</h5>\n<p><img src=\"https://oceaneyes.top/img/alipay.jpg\" title=\"支付宝打赏\" alt width=\"140\">\n<img src=\"https://oceaneyes.top/img/wechatpay.jpg\" title=\"微信打赏\" alt width=\"140\"></p>\n","more":"<h2 id=\"python设计模式-结构型适配器模式装饰者模式代理模式组合模式外观模式\">Python设计模式-结构型：适配器模式,装饰者模式,代理模式,组合模式,外观模式</h2>\n<ul>\n<li>适配器模式定义及简单实现案例</li>\n<li>装饰者模式定义及简单实现案例</li>\n<li>代理模式定义及简单实现案例</li>\n<li>组合模式定义及简单实现案例</li>\n<li>外观模式定义及简单实现案例</li>\n</ul>\n<h3 id=\"适配器模式-adapter\">适配器模式 adapter</h3>\n<p>电子产品的电源插头插在转换插头上，然后转换插头插上电源，电子产品就能正常工作了。这就是适配器模式</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\nclass OldCourse(object):\n    &quot;&quot;&quot;\n    老的课程类\n    &quot;&quot;&quot;\n\n    def show(self):\n        &quot;&quot;&quot;\n        显示关于本课程的所有信息\n        &quot;&quot;&quot;\n        print(&quot;show description&quot;)\n        print(&quot;show teacher of course&quot;)\n        print(&quot;show labs&quot;)\n\n\nclass Page(object):\n    &quot;&quot;&quot;\n    使用课程对象的客户端\n    &quot;&quot;&quot;\n\n    def __init__(self, course):\n        self.course = course\n\n    def render(self):\n        self.course.show()\n\n\nclass NewCourse(object):\n    &quot;&quot;&quot;\n    新的课程类, 为了模块化显示课程信息，实现了新的课程类\n    &quot;&quot;&quot;\n    def show_desc(self):\n        &quot;&quot;&quot;\n        显示描述信息\n        &quot;&quot;&quot;\n        print(&quot;show description&quot;)\n\n    def show_teacher(self):\n        &quot;&quot;&quot;\n        显示老师信息\n        &quot;&quot;&quot;\n        print(&quot;show teacher of course&quot;)\n\n    def show_labs(self):\n        &quot;&quot;&quot;\n        显示实验\n        &quot;&quot;&quot;\n        print(&quot;show labs&quot;)\n\n\nclass Adapter(object):\n    &quot;&quot;&quot;\n    适配器, 尽管实现了新的课程类，但是在很多代码中还是需要使用 OldCourse.show() 方法\n    &quot;&quot;&quot;\n\n    def __init__(self, course):\n        self.course = course\n\n    def show(self):\n        &quot;&quot;&quot;\n        适配方法，调用真正的操作\n        &quot;&quot;&quot;\n        self.course.show_desc()\n        self.course.show_teacher()\n        self.course.show_labs()\n\n\nif __name__ == &#39;__main__&#39;:\n    old_course = OldCourse()\n    page = Page(old_course)\n    page.render()\n    print(&quot;&quot;)\n    new_course = NewCourse()\n    # 新课程类没有 show 方法，我们需要使用适配器进行适配\n    adapter = Adapter(new_course)\n    page = Page(adapter)\n    page.render()</code></pre>\n<p><strong>适配器模式就是把一个类的接口变换成客户端所期待的另一种接口，使原本因接口不兼容而无法在一起工作的两个类能够在一起工作。</strong></p>\n<h3 id=\"装饰者模式-decorator\">装饰者模式 Decorator</h3>\n<p>装饰者模式能动态的给对象添加行为。如果你对 Flask\n比较熟悉的话，应该知道在使用 Flask-Login 的时候可以使用 login_required\n装饰器包装一个需要用户登录访问的view</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\nfrom functools import wraps\n\nHOST_DOCKER = 0\n\n\ndef docker_host_required(f):\n    &quot;&quot;&quot;\n    装饰器，必须要求 host 类型是 HOST_DOCKER\n    &quot;&quot;&quot;\n    @wraps(f)\n    def wrapper(*args, **kwargs):\n        if args[0].type != HOST_DOCKER:\n            raise Exception(&quot;Not docker host&quot;)\n        else:\n            return f(*args, **kwargs)\n    return wrapper\n\n\nclass Host(object):\n    &quot;&quot;&quot;\n    host 类\n    &quot;&quot;&quot;\n\n    def __init__(self, type):\n        self.type = type\n\n    # 装饰这一方法\n    @docker_host_required\n    def create_container(self):\n        print(&quot;create container&quot;)\n\n\nif __name__ == &#39;__main__&#39;:\n    # 初始化 Host\n    host = Host(HOST_DOCKER)\n    host.create_container()\n    print(&quot;&quot;)\n    # 再次初始化 Host\n    host = Host(1)\n    host.create_container()</code></pre>\n<p>在上面的代码中，Host有一个方法Host.create_container，只有当Host实例的类型是DOCKER_HOST的时候才能执行该方法。为了加上这一行为，我们使用了装饰者模式。可以看出使用装饰者模式，我们可以动态改变类的行为，同时能提高代码复用性，因为任何类型为HOST_DOCKER的Host都可以使用该装饰器。另外要说明下：为了更好的实现装饰器，我们使用functools.wrap函数。</p>\n<h3 id=\"代理模式-proxy\">代理模式 proxy</h3>\n<p>所谓代理模式就是给一个对象提供一个代理，并由代理对象控制对原对象的访问。通过代理，我们可以对访问做一些控制。在开发网站的过程中，针对一些频繁访问的资源，我们会使用缓存。</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\nfrom time import sleep\n\n\nclass Redis(object):\n    &quot;&quot;&quot;\n    用于模拟 redis 服务\n    &quot;&quot;&quot;\n\n    def __init__(self):\n        &quot;&quot;&quot;\n        使用字典存储数据\n        &quot;&quot;&quot;\n        self.cache = dict()\n\n    def get(self, key):\n        &quot;&quot;&quot;\n        获取数据\n        &quot;&quot;&quot;\n        return self.cache.get(key)\n\n    def set(self, key, value):\n        &quot;&quot;&quot;\n        设置数据\n        &quot;&quot;&quot;\n        self.cache[key] = value\n\n\nclass Image(object):\n    &quot;&quot;&quot;\n    图片对象，图片存在七牛云存储中，我们只保存了一个地址\n    &quot;&quot;&quot;\n\n    def __init__(self, name):\n        self.name = name\n\n    @property\n    def url(self):\n        sleep(2)\n        return &quot;https://dn-syl-static.qbox.me/img/logo-transparent.png&quot;\n\n\nclass Page(object):\n    &quot;&quot;&quot;\n    用于显示图片\n    &quot;&quot;&quot;\n\n    def __init__(self, image):\n        &quot;&quot;&quot;\n        需要图片进行初始化\n        &quot;&quot;&quot;\n        self.image = image\n\n    def render(self):\n        &quot;&quot;&quot;\n        显示图片\n        &quot;&quot;&quot;\n        print(self.image.url)\n\n\nredis = Redis()\n\n\nclass ImageProxy(object):\n    &quot;&quot;&quot;\n    图片代理，首次访问会从真正的图片对象中获取地址，以后都从 Redis 缓存中获取\n    &quot;&quot;&quot;\n\n    def __init__(self, image):\n        self.image = image\n\n    @property\n    def url(self):\n        addr = redis.get(self.image.name)\n        if not addr:\n            addr = self.image.url\n            print(&quot;Set url in redis cache!&quot;)\n            redis.set(self.image.name, addr)\n        else:\n            print(&quot;Get url from redis cache!&quot;)\n        return addr\n\n\nif __name__ == &#39;__main__&#39;:\n    img = Image(name=&quot;logo&quot;)\n    proxy = ImageProxy(img)\n    page = Page(proxy)\n    # 首次访问\n    page.render()\n    print(&quot;&quot;)\n    # 第二次访问\n    page.render()</code></pre>\n<p>代理对象和真实的对象之间都实现了共同的接口，这使我们可以在不改变原接口情况下，使用真实对象的地方都可以使用代理对象。其次，代理对象在客户端和真实对象之间直接起到了中介作用，同时通过代理对象，我们可以在将客户请求传递给真实对象之前做一些必要的预处理。</p>\n<h3 id=\"组合模式-composite\">组合模式 composite</h3>\n<p>什么是组合模式？按照定义来说，组合模式是将对象组合成树形结构表示，使得客户端对单个对象和组合对象的使用具有一致性。组合模式的使用通常会生成一棵对象树，对象树中的叶子结点代表单个对象，其他节点代表组合对象。调用某一组合对象的方法，其实会迭代调用所有其叶子对象的方法。</p>\n<p>使用组合模式的经典例子是 Linux\n系统内的树形菜单和文件系统。在树形菜单中，每一项菜单可能是一个组合对象，其包含了菜单项和子菜单，这样就形成了一棵对象树。在文件系统中，叶子对象就是文件，而文件夹就是组合对象，文件夹可以包含文件夹和文件，同样又形成了一棵对象树。同样的例子还有员工和领导之间的关系</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\nimport abc\n\n\nclass Worker(object):\n    &quot;&quot;&quot;\n    员工抽象类\n    &quot;&quot;&quot;\n    __metaclass__ = abc.ABCMeta\n\n    def __init__(self, name):\n        self.name = name\n\n    @abc.abstractmethod\n    def work(self):\n        pass\n\n\nclass Employe(Worker):\n    &quot;&quot;&quot;\n    员工类\n    &quot;&quot;&quot;\n    __metaclass__ = abc.ABCMeta\n\n    def work(self):\n        print(&quot;Employ: %s start to work &quot; % self.name)\n\n\nclass Leader(Worker):\n    &quot;&quot;&quot;\n    领导类\n    &quot;&quot;&quot;\n\n    def __init__(self, name):\n        self.members = []\n        super(Leader, self).__init__(name)\n\n    def add_member(self, employe):\n        if employe not in self.members:\n            self.members.append(employe)\n\n    def remove_member(self, employe):\n        if employe in self.members:\n            self.members.remove(employe)\n\n    def work(self):\n        print(&quot;Leader: %s start to work&quot; % self.name)\n        for employe in self.members:\n            employe.work()\n\n\nif __name__ == &#39;__main__&#39;:\n    employe_1 = Employe(&quot;employe_1&quot;)\n    employe_2 = Employe(&quot;employe_2&quot;)\n    leader_1 = Leader(&quot;leader_1&quot;)\n    leader_1.add_member(employe_1)\n    leader_1.add_member(employe_2)\n\n    employe_3 = Employe(&quot;employe_3&quot;)\n    leader_2 = Leader(&quot;leader_2&quot;)\n    leader_2.add_member(employe_3)\n    leader_2.add_member(leader_1)\n\n    leader_2.work()</code></pre>\n<h3 id=\"外观模式-facade\">外观模式 facade</h3>\n<p>所谓外观模式，就是将各种子系统的复杂操作通过外观模式简化，让客户端使用起来更方便简洁。\n-\n比如你夏天晚上出门时，要关闭电灯，关闭电视机，关闭空调，如果有了一个总开关，通过它可以关闭电灯，电视机和空调，你出门的时候关闭总开关就行了。\n- 在这个例子中，你就是客户端，总开关就是外观模式的化身</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\n\nclass User(object):\n    &quot;&quot;&quot;\n    用户类\n    &quot;&quot;&quot;\n    def is_login(self):\n        return True\n\n    def has_privilege(self, privilege):\n        return True\n\n\nclass Course(object):\n    &quot;&quot;&quot;\n    课程类\n    &quot;&quot;&quot;\n    def can_be_learned(self):\n        return True\n\n\nclass Lab(object):\n    &quot;&quot;&quot;\n    实验类\n    &quot;&quot;&quot;\n    def can_be_started(self):\n        return True\n\n\nclass Client(object):\n    &quot;&quot;&quot;\n    客户类，用于开始一个实验\n    &quot;&quot;&quot;\n    def __init__(self, user, course, lab):\n        self.user = user\n        self.course = course\n        self.lab = lab\n\n    def start_lab(self):\n        &quot;&quot;&quot;\n        开始实验，需要一系列的判断：用户是否登录，课程是否可以学习，实验是否可以开始。判断非常繁琐！\n        &quot;&quot;&quot;\n        if self.user.is_login() and self.course.can_be_learned() and self.lab.can_be_started():\n            print(&quot;start lab&quot;)\n        else:\n            print(&quot;can not start lab&quot;)\n\n\nclass FacadeLab(object):\n    &quot;&quot;&quot;\n    新的Lab类，应用了面向对象模式\n    &quot;&quot;&quot;\n\n    def __init__(self, user, course, lab):\n        self.user = user\n        self.course = course\n        self.lab = lab\n\n    def can_be_started(self):\n        if self.user.is_login() and self.course.can_be_learned() and self.lab.can_be_started():\n            return True\n        else:\n            return False\n\n\nclass NewClient(object):\n    &quot;&quot;&quot;\n    新的客户类，使用外观模式\n    &quot;&quot;&quot;\n    def __init__(self, facade_lab):\n        self.lab = facade_lab\n\n    def start_lab(self):\n        &quot;&quot;&quot;\n        开始实验，只需要判断 FacadeLab 是否可以开始\n        &quot;&quot;&quot;\n        if self.lab.can_be_started:\n            print(&quot;start lab&quot;)\n        else:\n            print(&quot;can not start lab&quot;)\n\n\nif __name__ == &#39;__main__&#39;:\n    user = User()\n    course = Course()\n    lab = Lab()\n    client = Client(user, course, lab)\n    client.start_lab()\n\n    print(&quot;Use Facade Pattern:&quot;)\n    facade_lab = FacadeLab(user, course, lab)\n    facade_client = NewClient(facade_lab)\n    facade_client.start_lab()\n</code></pre>\n<p>外观模式的主要目的在于降低系统的复杂程度，在面向对象软件系统中，类与类之间的关系越多，不能表示系统设计得越好，反而表示系统中类之间的耦合度太大，这样的系统在维护和修改时都缺乏灵活性，因为一个类的改动会导致多个类发生变化，而外观模式的引入在很大程度上降低了类与类之间的耦合关系。引入外观模式之后，增加新的子系统或者移除子系统都非常方便，客户类无须进行修改（或者极少的修改），只需要在外观类中增加或移除对子系统的引用即可。</p>\n<hr>\n<h3 id=\"about-me\">About ME</h3>\n<h5 id=\"读书城南-在未来面前我们都是孩子\">👋 读书城南，🤔\n在未来面前，我们都是孩子～</h5>\n<ul>\n<li>📙\n一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~</li>\n</ul>\n<h5 id=\"social-media\">👋 Social Media</h5>\n<ul>\n<li><p>🛠️ Blog: <a href=\"http://oceaneyes.top\">http://oceaneyes.top</a></p></li>\n<li><p>⚡ PM导航: <a href=\"https://pmhub.oceangzy.top\">https://pmhub.oceangzy.top</a></p></li>\n<li><p>☘️ CNBLOG: <a href=\"https://www.cnblogs.com/oceaneyes-gzy/\">https://www.cnblogs.com/oceaneyes-gzy/</a></p></li>\n<li><p>🌱 AI PRJ自己部署的一些算法demo: <a href=\"http://ai.oceangzy.top/\">http://ai.oceangzy.top/</a></p></li>\n<li><p>📫 Email: 1450136519@qq.com</p></li>\n<li><p>💬 WeChat: <a href=\"https://oceaneyes.top/img/wechatqrcode.jpg\">OCEANGZY</a></p></li>\n<li><p>💬 公众号: <a href=\"https://oceaneyes.top/img/wechatgzh.jpeg\">UncleJoker-GZY</a></p></li>\n</ul>\n<h5 id=\"加入小组\">👋 加入小组~</h5>\n<p><img src=\"https://oceaneyes.top/img/zhishigroup.jpg\" title=\"加入组织\" alt width=\"240\"></p>\n<h5 id=\"感谢打赏\">👋 感谢打赏~</h5>\n<p><img src=\"https://oceaneyes.top/img/alipay.jpg\" title=\"支付宝打赏\" alt width=\"140\">\n<img src=\"https://oceaneyes.top/img/wechatpay.jpg\" title=\"微信打赏\" alt width=\"140\"></p>\n","categories":[{"name":"Python3","path":"api/categories/Python3.json"}],"tags":[{"name":"Python3","path":"api/tags/Python3.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}