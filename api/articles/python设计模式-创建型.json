{"title":"Python设计模式-创建型","slug":"python设计模式-创建型","date":"2022-06-01T15:30:00.000Z","updated":"2022-09-30T06:56:37.181Z","comments":true,"path":"api/articles/python设计模式-创建型.json","excerpt":null,"covers":["https://oceaneyes.top/img/zhishigroup.jpg","https://oceaneyes.top/img/alipay.jpg","https://oceaneyes.top/img/wechatpay.jpg"],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"python设计模式-创建型单例模式和工厂模式家族\">Python设计模式-创建型：单例模式和工厂模式家族</h2>\n<p><strong>知识点</strong>： - 单例模式概念及一般实现 -\n单例模式的装饰器实现 - 简单工厂模式 - 抽象工厂模式</p>\n<h3 id=\"单例模式singleton\">单例模式(singleton)</h3>\n<blockquote>\n<ul>\n<li>所谓单例模式，也就是说不管什么时候我们要确保只有一个对象实例存在。</li>\n<li>很多情况下，整个系统中只需要存在一个对象，所有的信息都从这个对象获取，比如系统的配置对象，或者是线程池。</li>\n<li>这些场景下，就非常适合使用单例模式。总结起来，就是说不管我们初始化一个对象多少次，真正干活的对象只会生成一次并且在首次生成。</li>\n</ul>\n</blockquote>\n<h4 id=\"singleton._instance\">Singleton._instance</h4>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\nclass Singleton(object):\n    &quot;&quot;&quot;\n    单例模式\n    &quot;&quot;&quot;\n    class _A(object):\n        &quot;&quot;&quot;\n       真正干活的类, 对外隐藏\n        &quot;&quot;&quot;\n        def __init__(self):\n            pass\n\n        def display(self):\n            &quot;&quot;&quot; 返回当前实例的 ID，是全局唯一的&quot;&quot;&quot;\n            return id(self)\n\n    # 类变量，用于存储 _A 的实例\n    _instance = None\n\n    def __init__(self):\n        &quot;&quot;&quot; 先判断类变量中是否已经保存了 _A 的实例，如果没有则创建一个后返回&quot;&quot;&quot;\n        if Singleton._instance is None:\n            Singleton._instance = Singleton._A()\n\n    def __getattr__(self, attr):\n        &quot;&quot;&quot; 所有的属性都应该直接从 Singleton._instance 获取&quot;&quot;&quot;\n        return getattr(self._instance, attr)\n\n\nif __name__ == &#39;__main__&#39;:\n    # 创建两个实例\n    s1 = Singleton()\n    s2 = Singleton()\n    print(id(s1), s1.display())\n    print(id(s2), s2.display())\n\n</code></pre>\n<ul>\n<li><p>使用类变量 Singleton._instance\n来存储创建的实例，并且保证只会创建一次实例。</p></li>\n<li><p>由于 Python 是一门动态语言，我们可以在运行时改变类定义。</p></li>\n<li><p>在首次初始化Singleton时，我们将首次生成类_A的实例,并将其存储到\nSingleton._instance 中，以后每次初始化 Singleton 时都从\nSingleton._instance\n获取真正干活的实例，这样我们就实现了单例模式。</p></li>\n</ul>\n<h4 id=\"装饰器\">装饰器</h4>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\nclass Singleton:\n\n    &quot;&quot;&quot;\n    单例类装饰器，可以用于想实现单例的任何类。注意，不能用于多线程环境。\n    &quot;&quot;&quot;\n\n    def __init__(self, cls):\n        &quot;&quot;&quot; 需要的参数是一个类 &quot;&quot;&quot;\n        self._cls = cls\n\n    def Instance(self):\n        &quot;&quot;&quot;\n        返回真正的实例\n        &quot;&quot;&quot;\n        try:\n            return self._instance\n        except AttributeError:\n            self._instance = self._cls()\n            return self._instance\n\n    def __call__(self):\n        raise TypeError(&#39;Singletons must be accessed through `Instance()`.&#39;)\n\n    def __instancecheck__(self, inst):\n        return isinstance(inst, self._decorated)\n\n\n# 装饰器\n@Singleton\nclass A:\n    &quot;&quot;&quot;一个需要单例模式的类&quot;&quot;&quot;\n    def __init__(self):\n        pass\n\n    def display(self):\n        return id(self)\n\nif __name__ == &#39;__main__&#39;:\n    s1 = A.Instance()\n    s2 = A.Instance()\n    print(s1, s1.display())\n    print(s2, s2.display())\n    print(s1 is s2)\n</code></pre>\n<ul>\n<li>用装饰器实现了单例模式，任何想使用单例模式的类，只需要使用 Singleton\n装饰器装饰一下就可以使用了。</li>\n<li>可以看到其核心工作原理其实和第一种实现方式是一致的，也是使用内置的属性\nSingleton._instance\n来存储实例的。通过使用装饰器的模式我们将代码解耦了，使用更加灵活</li>\n</ul>\n<h4 id=\"案例-单例模式-连接sqlite3数据库\">案例-单例模式-连接sqlite3数据库</h4>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\n\nimport sqlite3\nfrom flask import current_app\nfrom flask import _app_ctx_stack as stack\n\n\nclass SQLite3(object):\n\n    def __init__(self, app=None):\n        self.app = app\n        if app is not None:\n            self.init_app(app)\n\n    def init_app(self, app):\n        &quot;&quot;&quot;\n        典型的 Flask 扩展的初始化方式\n        &quot;&quot;&quot;\n        app.config.setdefault(&#39;SQLITE3_DATABASE&#39;, &#39;:memory:&#39;)\n        app.teardown_appcontext(self.teardown)\n\n    def connect(self):\n        &quot;&quot;&quot;\n        连接到 sqlite 数据库\n        &quot;&quot;&quot;\n        return sqlite3.connect(current_app.config[&#39;SQLITE3_DATABASE&#39;])\n\n    def teardown(self, exception):\n          &quot;&quot;&quot;\n          关闭 sqlite 链接\n          &quot;&quot;&quot;\n        ctx = stack.top\n        if hasattr(ctx, &#39;sqlite3_db&#39;):\n            ctx.sqlite3_db.close()\n\n    @property\n    def connection(self):\n        &quot;&quot;&quot;\n        单例模式在这里：使用 flask._app_ctx_stack 存放 sqlite 链接,\n        每次获取数据库链接时都通过 connection 获取\n        &quot;&quot;&quot;\n        ctx = stack.top\n        if ctx is not None:\n            if not hasattr(ctx, &#39;sqlite3_db&#39;):\n                ctx.sqlite3_db = self.connect()\n            return ctx.sqlite3_db</code></pre>\n<h3 id=\"简单工厂模式-simple-factory\">简单工厂模式 Simple factory</h3>\n<p>一个函数，传入需要创建的产品类型，然后返回相应的产品</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\n\nimport random\n\n\nclass BasicCourse(object):\n    &quot;&quot;&quot;\n    基础课程\n    &quot;&quot;&quot;\n    def get_labs(self):\n        return &quot;basic_course: labs&quot;\n\n    def __str__(self):\n        return &quot;BasciCourse&quot;\n\n\nclass ProjectCourse(object):\n    &quot;&quot;&quot;\n    项目课\n    &quot;&quot;&quot;\n\n    def get_labs(self):\n        return &quot;project_course: labs&quot;\n\n    def __str__(self):\n        return &quot;ProjectCourse&quot;\n\n\nclass SimpleCourseFactory(object):\n\n    @staticmethod\n    def create_course(type):\n        &quot;&quot;&quot; 简单工厂，用于创建课程&quot;&quot;&quot;\n        if type == &#39;bc&#39;:\n            return BasicCourse()\n        elif type == &#39;pc&#39;:\n            return ProjectCourse()\n\n\nif __name__ == &#39;__main__&#39;:\n    t = random.choice([&#39;bc&#39;, &#39;pc&#39;])\n    course = SimpleCourseFactory.create_course(t)\n    print(course.get_labs())\n</code></pre>\n<h3 id=\"工厂方法模式-factory-method\">工厂方法模式 factory method</h3>\n<p>上面的简单工厂模式中，我们遇到了问题：如果需要增加一种课程，那我们需要修改工厂代码。仔细想想，如果对工厂进行抽象化，让每个工厂只负责一种产品的生产，那这样当增加一种产品时，就不需要修改已有的工厂了，只需要新增加一个工厂就行了，这样就避免修改整个工厂了</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\nimport random\nimport abc\n\n\nclass BasicCourse(object):\n    &quot;&quot;&quot;\n        基础课程\n        &quot;&quot;&quot;\n    def get_labs(self):\n        return &quot;basic_course: labs&quot;\n\n    def __str__(self):\n        return &quot;BasicCourse&quot;\n\n\nclass ProjectCourse(object):\n    &quot;&quot;&quot;\n        项目课\n        &quot;&quot;&quot;\n\n    def get_labs(self):\n        return &quot;project_course: labs&quot;\n\n    def __str__(self):\n        return &quot;ProjectCourse&quot;\n\n\nclass Factory(metaclass=abc.ABCMeta):\n    &quot;&quot;&quot;\n        抽象工厂类\n        &quot;&quot;&quot;\n\n    @abc.abstractmethod\n    def create_course(self):\n        pass\n\n\nclass BasicCourseFactory(Factory):\n    &quot;&quot;&quot;\n        基础课程工厂类\n        &quot;&quot;&quot;\n\n    def create_course(self):\n        return BasicCourse()\n\n\nclass ProjectCourseFactory(Factory):\n    &quot;&quot;&quot;\n        项目课程工厂类\n        &quot;&quot;&quot;\n    def create_course(self):\n        return ProjectCourse()\n\n\ndef get_factory():\n    &quot;&quot;&quot;\n        随机获取一个工厂类\n        &quot;&quot;&quot;\n    return random.choice([BasicCourseFactory, ProjectCourseFactory])()\n\n\nif __name__ == &#39;__main__&#39;:\n    factory = get_factory()\n    course = factory.create_course()\n    print(course.get_labs())\n</code></pre>\n<p>我们有两种课程：BasicCourse 和\nProjectCourse，分别对应基础课和项目课。接着，我们创建了一个抽象的工厂\nFactory，该工厂有一抽象方法Factory.create_course用于创建课程，最后我们基于抽象工厂实现了生产基础课程的工厂BasicCourseFactory和生产项目课的工厂ProjectCourseFactory。这样当我们新增加一种课程时，就不需要修改已经存在的基础课工厂和项目课工厂了。这里需要说明下，我们通过\nPython 的abc模块实现抽象类和抽象方法。</p>\n<h3 id=\"抽象工厂模式\">抽象工厂模式</h3>\n<p>在工厂方法模式中，我们会遇到一个问题，当产品非常多时，继续使用工厂方法模式会产生非常多的工厂类。</p>\n<p>如果按照工厂方法模式的作法，我们需要创建 Linux 虚拟机工厂类和 Mac\n虚拟机工厂类，\n这样我们就会有一堆工厂类了。我们就不能创建出一个能同时创建课程和虚拟机的工厂吗？</p>\n<pre class=\"python3\"><code>-*- coding: utf-8 -*-\n\nimport random\nimport abc\n\n# 两种类型的课程\nclass BasicCourse(object):\n    &quot;&quot;&quot;\n    基础课程\n    &quot;&quot;&quot;\n    def get_labs(self):\n        return &quot;basic_course: labs&quot;\n\n    def __str__(self):\n        return &quot;BasicCourse&quot;\n\n\nclass ProjectCourse(object):\n    &quot;&quot;&quot;\n    项目课\n    &quot;&quot;&quot;\n\n    def get_labs(self):\n        return &quot;project_course: labs&quot;\n\n    def __str__(self):\n        return &quot;ProjectCourse&quot;\n\n\n# 两种类型的虚拟机\nclass LinuxVm(object):\n    &quot;&quot;&quot;\n    Linux 虚拟机\n    &quot;&quot;&quot;\n\n    def start(self):\n        return &quot;Linux vm running&quot;\n\n\nclass MacVm(object):\n    &quot;&quot;&quot;\n    Mac OSX 虚拟机\n    &quot;&quot;&quot;\n\n    def start(self):\n        return &quot;Mac OSX vm running&quot;\n\n\nclass Factory(metaclass=abc.ABCMeta):\n    &quot;&quot;&quot;\n    抽象工厂类, 现在工厂类不仅能创建课程，还能创建虚拟机了\n    &quot;&quot;&quot;\n\n    @abc.abstractmethod\n    def create_course(self):\n        pass\n\n    @abc.abstractmethod\n    def create_vm(self):\n        pass\n\n\nclass BasicCourseLinuxFactory(Factory):\n    &quot;&quot;&quot;\n    基础课程工厂类\n    &quot;&quot;&quot;\n\n    def create_course(self):\n        return BasicCourse()\n\n    def create_vm(self):\n        return LinuxVm()\n\n\nclass ProjectCourseMacFactory(Factory):\n    &quot;&quot;&quot;\n    项目课程工厂类\n    &quot;&quot;&quot;\n\n    def create_course(self):\n        return ProjectCourse()\n\n    def create_vm(self):\n        return MacVm()\n\n\ndef get_factory():\n    &quot;&quot;&quot;\n    随机获取一个工厂类\n    &quot;&quot;&quot;\n    return random.choice([BasicCourseLinuxFactory, ProjectCourseMacFactory])()\n\n\nif __name__ == &#39;__main__&#39;:\n    factory = get_factory()\n    course = factory.create_course()\n    vm = factory.create_vm()\n    print(course.get_labs())\n    print(vm.start())\n</code></pre>\n<hr>\n<h3 id=\"about-me\">About ME</h3>\n<h5 id=\"读书城南-在未来面前我们都是孩子\">👋 读书城南，🤔\n在未来面前，我们都是孩子～</h5>\n<ul>\n<li>📙\n一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~</li>\n</ul>\n<h5 id=\"social-media\">👋 Social Media</h5>\n<ul>\n<li><p>🛠️ Blog: <a href=\"http://oceaneyes.top\">http://oceaneyes.top</a></p></li>\n<li><p>⚡ PM导航: <a href=\"https://pmhub.oceangzy.top\">https://pmhub.oceangzy.top</a></p></li>\n<li><p>☘️ CNBLOG: <a href=\"https://www.cnblogs.com/oceaneyes-gzy/\">https://www.cnblogs.com/oceaneyes-gzy/</a></p></li>\n<li><p>🌱 AI PRJ自己部署的一些算法demo: <a href=\"http://ai.oceangzy.top/\">http://ai.oceangzy.top/</a></p></li>\n<li><p>📫 Email: 1450136519@qq.com</p></li>\n<li><p>💬 WeChat: <a href=\"https://oceaneyes.top/img/wechatqrcode.jpg\">OCEANGZY</a></p></li>\n<li><p>💬 公众号: <a href=\"https://oceaneyes.top/img/wechatgzh.jpeg\">UncleJoker-GZY</a></p></li>\n</ul>\n<h5 id=\"加入小组\">👋 加入小组~</h5>\n<p><img src=\"https://oceaneyes.top/img/zhishigroup.jpg\" title=\"加入组织\" alt width=\"240\"></p>\n<h5 id=\"感谢打赏\">👋 感谢打赏~</h5>\n<p><img src=\"https://oceaneyes.top/img/alipay.jpg\" title=\"支付宝打赏\" alt width=\"140\">\n<img src=\"https://oceaneyes.top/img/wechatpay.jpg\" title=\"微信打赏\" alt width=\"140\"></p>\n","more":"<h2 id=\"python设计模式-创建型单例模式和工厂模式家族\">Python设计模式-创建型：单例模式和工厂模式家族</h2>\n<p><strong>知识点</strong>： - 单例模式概念及一般实现 -\n单例模式的装饰器实现 - 简单工厂模式 - 抽象工厂模式</p>\n<h3 id=\"单例模式singleton\">单例模式(singleton)</h3>\n<blockquote>\n<ul>\n<li>所谓单例模式，也就是说不管什么时候我们要确保只有一个对象实例存在。</li>\n<li>很多情况下，整个系统中只需要存在一个对象，所有的信息都从这个对象获取，比如系统的配置对象，或者是线程池。</li>\n<li>这些场景下，就非常适合使用单例模式。总结起来，就是说不管我们初始化一个对象多少次，真正干活的对象只会生成一次并且在首次生成。</li>\n</ul>\n</blockquote>\n<h4 id=\"singleton._instance\">Singleton._instance</h4>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\nclass Singleton(object):\n    &quot;&quot;&quot;\n    单例模式\n    &quot;&quot;&quot;\n    class _A(object):\n        &quot;&quot;&quot;\n       真正干活的类, 对外隐藏\n        &quot;&quot;&quot;\n        def __init__(self):\n            pass\n\n        def display(self):\n            &quot;&quot;&quot; 返回当前实例的 ID，是全局唯一的&quot;&quot;&quot;\n            return id(self)\n\n    # 类变量，用于存储 _A 的实例\n    _instance = None\n\n    def __init__(self):\n        &quot;&quot;&quot; 先判断类变量中是否已经保存了 _A 的实例，如果没有则创建一个后返回&quot;&quot;&quot;\n        if Singleton._instance is None:\n            Singleton._instance = Singleton._A()\n\n    def __getattr__(self, attr):\n        &quot;&quot;&quot; 所有的属性都应该直接从 Singleton._instance 获取&quot;&quot;&quot;\n        return getattr(self._instance, attr)\n\n\nif __name__ == &#39;__main__&#39;:\n    # 创建两个实例\n    s1 = Singleton()\n    s2 = Singleton()\n    print(id(s1), s1.display())\n    print(id(s2), s2.display())\n\n</code></pre>\n<ul>\n<li><p>使用类变量 Singleton._instance\n来存储创建的实例，并且保证只会创建一次实例。</p></li>\n<li><p>由于 Python 是一门动态语言，我们可以在运行时改变类定义。</p></li>\n<li><p>在首次初始化Singleton时，我们将首次生成类_A的实例,并将其存储到\nSingleton._instance 中，以后每次初始化 Singleton 时都从\nSingleton._instance\n获取真正干活的实例，这样我们就实现了单例模式。</p></li>\n</ul>\n<h4 id=\"装饰器\">装饰器</h4>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\nclass Singleton:\n\n    &quot;&quot;&quot;\n    单例类装饰器，可以用于想实现单例的任何类。注意，不能用于多线程环境。\n    &quot;&quot;&quot;\n\n    def __init__(self, cls):\n        &quot;&quot;&quot; 需要的参数是一个类 &quot;&quot;&quot;\n        self._cls = cls\n\n    def Instance(self):\n        &quot;&quot;&quot;\n        返回真正的实例\n        &quot;&quot;&quot;\n        try:\n            return self._instance\n        except AttributeError:\n            self._instance = self._cls()\n            return self._instance\n\n    def __call__(self):\n        raise TypeError(&#39;Singletons must be accessed through `Instance()`.&#39;)\n\n    def __instancecheck__(self, inst):\n        return isinstance(inst, self._decorated)\n\n\n# 装饰器\n@Singleton\nclass A:\n    &quot;&quot;&quot;一个需要单例模式的类&quot;&quot;&quot;\n    def __init__(self):\n        pass\n\n    def display(self):\n        return id(self)\n\nif __name__ == &#39;__main__&#39;:\n    s1 = A.Instance()\n    s2 = A.Instance()\n    print(s1, s1.display())\n    print(s2, s2.display())\n    print(s1 is s2)\n</code></pre>\n<ul>\n<li>用装饰器实现了单例模式，任何想使用单例模式的类，只需要使用 Singleton\n装饰器装饰一下就可以使用了。</li>\n<li>可以看到其核心工作原理其实和第一种实现方式是一致的，也是使用内置的属性\nSingleton._instance\n来存储实例的。通过使用装饰器的模式我们将代码解耦了，使用更加灵活</li>\n</ul>\n<h4 id=\"案例-单例模式-连接sqlite3数据库\">案例-单例模式-连接sqlite3数据库</h4>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\n\nimport sqlite3\nfrom flask import current_app\nfrom flask import _app_ctx_stack as stack\n\n\nclass SQLite3(object):\n\n    def __init__(self, app=None):\n        self.app = app\n        if app is not None:\n            self.init_app(app)\n\n    def init_app(self, app):\n        &quot;&quot;&quot;\n        典型的 Flask 扩展的初始化方式\n        &quot;&quot;&quot;\n        app.config.setdefault(&#39;SQLITE3_DATABASE&#39;, &#39;:memory:&#39;)\n        app.teardown_appcontext(self.teardown)\n\n    def connect(self):\n        &quot;&quot;&quot;\n        连接到 sqlite 数据库\n        &quot;&quot;&quot;\n        return sqlite3.connect(current_app.config[&#39;SQLITE3_DATABASE&#39;])\n\n    def teardown(self, exception):\n          &quot;&quot;&quot;\n          关闭 sqlite 链接\n          &quot;&quot;&quot;\n        ctx = stack.top\n        if hasattr(ctx, &#39;sqlite3_db&#39;):\n            ctx.sqlite3_db.close()\n\n    @property\n    def connection(self):\n        &quot;&quot;&quot;\n        单例模式在这里：使用 flask._app_ctx_stack 存放 sqlite 链接,\n        每次获取数据库链接时都通过 connection 获取\n        &quot;&quot;&quot;\n        ctx = stack.top\n        if ctx is not None:\n            if not hasattr(ctx, &#39;sqlite3_db&#39;):\n                ctx.sqlite3_db = self.connect()\n            return ctx.sqlite3_db</code></pre>\n<h3 id=\"简单工厂模式-simple-factory\">简单工厂模式 Simple factory</h3>\n<p>一个函数，传入需要创建的产品类型，然后返回相应的产品</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\n\nimport random\n\n\nclass BasicCourse(object):\n    &quot;&quot;&quot;\n    基础课程\n    &quot;&quot;&quot;\n    def get_labs(self):\n        return &quot;basic_course: labs&quot;\n\n    def __str__(self):\n        return &quot;BasciCourse&quot;\n\n\nclass ProjectCourse(object):\n    &quot;&quot;&quot;\n    项目课\n    &quot;&quot;&quot;\n\n    def get_labs(self):\n        return &quot;project_course: labs&quot;\n\n    def __str__(self):\n        return &quot;ProjectCourse&quot;\n\n\nclass SimpleCourseFactory(object):\n\n    @staticmethod\n    def create_course(type):\n        &quot;&quot;&quot; 简单工厂，用于创建课程&quot;&quot;&quot;\n        if type == &#39;bc&#39;:\n            return BasicCourse()\n        elif type == &#39;pc&#39;:\n            return ProjectCourse()\n\n\nif __name__ == &#39;__main__&#39;:\n    t = random.choice([&#39;bc&#39;, &#39;pc&#39;])\n    course = SimpleCourseFactory.create_course(t)\n    print(course.get_labs())\n</code></pre>\n<h3 id=\"工厂方法模式-factory-method\">工厂方法模式 factory method</h3>\n<p>上面的简单工厂模式中，我们遇到了问题：如果需要增加一种课程，那我们需要修改工厂代码。仔细想想，如果对工厂进行抽象化，让每个工厂只负责一种产品的生产，那这样当增加一种产品时，就不需要修改已有的工厂了，只需要新增加一个工厂就行了，这样就避免修改整个工厂了</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\nimport random\nimport abc\n\n\nclass BasicCourse(object):\n    &quot;&quot;&quot;\n        基础课程\n        &quot;&quot;&quot;\n    def get_labs(self):\n        return &quot;basic_course: labs&quot;\n\n    def __str__(self):\n        return &quot;BasicCourse&quot;\n\n\nclass ProjectCourse(object):\n    &quot;&quot;&quot;\n        项目课\n        &quot;&quot;&quot;\n\n    def get_labs(self):\n        return &quot;project_course: labs&quot;\n\n    def __str__(self):\n        return &quot;ProjectCourse&quot;\n\n\nclass Factory(metaclass=abc.ABCMeta):\n    &quot;&quot;&quot;\n        抽象工厂类\n        &quot;&quot;&quot;\n\n    @abc.abstractmethod\n    def create_course(self):\n        pass\n\n\nclass BasicCourseFactory(Factory):\n    &quot;&quot;&quot;\n        基础课程工厂类\n        &quot;&quot;&quot;\n\n    def create_course(self):\n        return BasicCourse()\n\n\nclass ProjectCourseFactory(Factory):\n    &quot;&quot;&quot;\n        项目课程工厂类\n        &quot;&quot;&quot;\n    def create_course(self):\n        return ProjectCourse()\n\n\ndef get_factory():\n    &quot;&quot;&quot;\n        随机获取一个工厂类\n        &quot;&quot;&quot;\n    return random.choice([BasicCourseFactory, ProjectCourseFactory])()\n\n\nif __name__ == &#39;__main__&#39;:\n    factory = get_factory()\n    course = factory.create_course()\n    print(course.get_labs())\n</code></pre>\n<p>我们有两种课程：BasicCourse 和\nProjectCourse，分别对应基础课和项目课。接着，我们创建了一个抽象的工厂\nFactory，该工厂有一抽象方法Factory.create_course用于创建课程，最后我们基于抽象工厂实现了生产基础课程的工厂BasicCourseFactory和生产项目课的工厂ProjectCourseFactory。这样当我们新增加一种课程时，就不需要修改已经存在的基础课工厂和项目课工厂了。这里需要说明下，我们通过\nPython 的abc模块实现抽象类和抽象方法。</p>\n<h3 id=\"抽象工厂模式\">抽象工厂模式</h3>\n<p>在工厂方法模式中，我们会遇到一个问题，当产品非常多时，继续使用工厂方法模式会产生非常多的工厂类。</p>\n<p>如果按照工厂方法模式的作法，我们需要创建 Linux 虚拟机工厂类和 Mac\n虚拟机工厂类，\n这样我们就会有一堆工厂类了。我们就不能创建出一个能同时创建课程和虚拟机的工厂吗？</p>\n<pre class=\"python3\"><code>-*- coding: utf-8 -*-\n\nimport random\nimport abc\n\n# 两种类型的课程\nclass BasicCourse(object):\n    &quot;&quot;&quot;\n    基础课程\n    &quot;&quot;&quot;\n    def get_labs(self):\n        return &quot;basic_course: labs&quot;\n\n    def __str__(self):\n        return &quot;BasicCourse&quot;\n\n\nclass ProjectCourse(object):\n    &quot;&quot;&quot;\n    项目课\n    &quot;&quot;&quot;\n\n    def get_labs(self):\n        return &quot;project_course: labs&quot;\n\n    def __str__(self):\n        return &quot;ProjectCourse&quot;\n\n\n# 两种类型的虚拟机\nclass LinuxVm(object):\n    &quot;&quot;&quot;\n    Linux 虚拟机\n    &quot;&quot;&quot;\n\n    def start(self):\n        return &quot;Linux vm running&quot;\n\n\nclass MacVm(object):\n    &quot;&quot;&quot;\n    Mac OSX 虚拟机\n    &quot;&quot;&quot;\n\n    def start(self):\n        return &quot;Mac OSX vm running&quot;\n\n\nclass Factory(metaclass=abc.ABCMeta):\n    &quot;&quot;&quot;\n    抽象工厂类, 现在工厂类不仅能创建课程，还能创建虚拟机了\n    &quot;&quot;&quot;\n\n    @abc.abstractmethod\n    def create_course(self):\n        pass\n\n    @abc.abstractmethod\n    def create_vm(self):\n        pass\n\n\nclass BasicCourseLinuxFactory(Factory):\n    &quot;&quot;&quot;\n    基础课程工厂类\n    &quot;&quot;&quot;\n\n    def create_course(self):\n        return BasicCourse()\n\n    def create_vm(self):\n        return LinuxVm()\n\n\nclass ProjectCourseMacFactory(Factory):\n    &quot;&quot;&quot;\n    项目课程工厂类\n    &quot;&quot;&quot;\n\n    def create_course(self):\n        return ProjectCourse()\n\n    def create_vm(self):\n        return MacVm()\n\n\ndef get_factory():\n    &quot;&quot;&quot;\n    随机获取一个工厂类\n    &quot;&quot;&quot;\n    return random.choice([BasicCourseLinuxFactory, ProjectCourseMacFactory])()\n\n\nif __name__ == &#39;__main__&#39;:\n    factory = get_factory()\n    course = factory.create_course()\n    vm = factory.create_vm()\n    print(course.get_labs())\n    print(vm.start())\n</code></pre>\n<hr>\n<h3 id=\"about-me\">About ME</h3>\n<h5 id=\"读书城南-在未来面前我们都是孩子\">👋 读书城南，🤔\n在未来面前，我们都是孩子～</h5>\n<ul>\n<li>📙\n一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~</li>\n</ul>\n<h5 id=\"social-media\">👋 Social Media</h5>\n<ul>\n<li><p>🛠️ Blog: <a href=\"http://oceaneyes.top\">http://oceaneyes.top</a></p></li>\n<li><p>⚡ PM导航: <a href=\"https://pmhub.oceangzy.top\">https://pmhub.oceangzy.top</a></p></li>\n<li><p>☘️ CNBLOG: <a href=\"https://www.cnblogs.com/oceaneyes-gzy/\">https://www.cnblogs.com/oceaneyes-gzy/</a></p></li>\n<li><p>🌱 AI PRJ自己部署的一些算法demo: <a href=\"http://ai.oceangzy.top/\">http://ai.oceangzy.top/</a></p></li>\n<li><p>📫 Email: 1450136519@qq.com</p></li>\n<li><p>💬 WeChat: <a href=\"https://oceaneyes.top/img/wechatqrcode.jpg\">OCEANGZY</a></p></li>\n<li><p>💬 公众号: <a href=\"https://oceaneyes.top/img/wechatgzh.jpeg\">UncleJoker-GZY</a></p></li>\n</ul>\n<h5 id=\"加入小组\">👋 加入小组~</h5>\n<p><img src=\"https://oceaneyes.top/img/zhishigroup.jpg\" title=\"加入组织\" alt width=\"240\"></p>\n<h5 id=\"感谢打赏\">👋 感谢打赏~</h5>\n<p><img src=\"https://oceaneyes.top/img/alipay.jpg\" title=\"支付宝打赏\" alt width=\"140\">\n<img src=\"https://oceaneyes.top/img/wechatpay.jpg\" title=\"微信打赏\" alt width=\"140\"></p>\n","categories":[{"name":"Python3","path":"api/categories/Python3.json"}],"tags":[{"name":"Python3","path":"api/tags/Python3.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}