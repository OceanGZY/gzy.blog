{"title":"Python设计模式-行为型","slug":"python设计模式-行为型","date":"2022-06-01T15:31:00.000Z","updated":"2022-09-30T06:56:37.181Z","comments":true,"path":"api/articles/python设计模式-行为型.json","excerpt":null,"covers":["https://oceaneyes.top/img/zhishigroup.jpg","https://oceaneyes.top/img/alipay.jpg","https://oceaneyes.top/img/wechatpay.jpg"],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"python设计模式-行为型策略模式观察者模式命令模式模板方法\">Python设计模式-行为型：策略模式,观察者模式,命令模式,模板方法</h2>\n<blockquote>\n<p>行为型模式会涉及到算法和对象间的职责分配，不仅描述对象或类的模式，还描述它们之间的通信方式，刻划了运行时难以跟踪的复杂的控制流，它们将你的注意力从控制流转移到对象间的关系上来。</p>\n</blockquote>\n<ul>\n<li>策略模式定义及简单实现案例</li>\n<li>观察者模式定义及简单实现案例</li>\n<li>命令模式定义及简单实现案例</li>\n<li>模板方法模式定义及简单实现案例</li>\n</ul>\n<h3 id=\"策略模式-strategy\">策略模式 strategy</h3>\n<pre><code>case:一个问题可能有多种显示方式。如果用户有管理权限，那么问题的详情页面可能会显示编辑按钮，如果是普通用户则只显示问题内容。这样一个对象我们该怎么实现呢</code></pre>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\nclass Question(object):\n    &quot;&quot;&quot;\n    问题对象，没有使用策略模式之前的作法\n    &quot;&quot;&quot;\n\n    def __init__(self, admin=True):\n        self._admin = admin\n\n    def show(self):\n        &quot;&quot;&quot;\n        根据是否是管理员显示不同的信息\n        &quot;&quot;&quot;\n        if self._admin is True:\n            return &quot;show page with admin&quot;\n        else:\n            return &quot;show page with user&quot;\n\n\nif __name__ == &#39;__main__&#39;:\n    q = Question(admin=False)\n    print(q.show())</code></pre>\n<p>以上代码中，最重要的操作就是Question.show操作，它会根据Quesiton._admin标志的不同完成两种显示。</p>\n<p>现在我们有一些新的需求，增加Question的显示方式，怎么办？ -\n如果增加更多的显示方式，按照以上作法，我们必然要修改Quesiton.show方法，并增加更多的标志位。\n-\n这样一来Question在面对不断增加的显示需求时都需要修改其代码，显然这是一种不好的设计。</p>\n<p>下面该轮到策略模式发挥作用的时候了，策略模式将各种操作（算法）进行封装，并使它们之间可以互换。互换的意思是说可以动态改变对象的操作方式（算法）。</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\nimport abc\n\n\nclass AbsShow(object):\n    &quot;&quot;&quot;\n    抽象显示对象\n    &quot;&quot;&quot;\n\n    __metaclass__ = abc.ABCMeta\n\n    @abc.abstractmethod\n    def show(self):\n        pass\n\n\nclass AdminShow(AbsShow):\n    &quot;&quot;&quot;\n    管理员的显示操作\n    &quot;&quot;&quot;\n\n    def show(self):\n        return &quot;show with admin&quot;\n\n\nclass UserShow(AbsShow):\n    &quot;&quot;&quot;\n    普通用户的显示操作\n    &quot;&quot;&quot;\n\n    def show(self):\n        return &quot;show with user&quot;\n\n\nclass Question(object):\n    &quot;&quot;&quot;\n    问题对象，使用策略模式之后的作法\n    &quot;&quot;&quot;\n\n    def __init__(self, show_obj):\n        self.show_obj = show_obj\n\n    def show(self):\n        return self.show_obj.show()\n\n\n\nif __name__ == &#39;__main__&#39;:\n    q = Question(show_obj=AdminShow())\n    print(q.show())\n    # 替换原来的显示对象，体现了策略模式的互换行为\n    q.show_obj = UserShow()\n    print(q.show())</code></pre>\n<p>将 Question\n对象和显示方法进行了解耦，增加新的显示方法时，只需要增加新的显示对象就可以了。同时，在代码中还可以看到我们可以动态改变\nQuestion 的显示方式，这也体现了策略模式的互换行为。</p>\n<h3 id=\"观察者模式-observer\">观察者模式 Observer</h3>\n<p>所谓观察者模式，就是说当一个对象发生变化时，观察者能及时得到通知并更新</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\nimport abc\n\n\nclass Subject(object):\n    &quot;&quot;&quot;\n    被观察对象的基类\n    &quot;&quot;&quot;\n\n    def __init__(self):\n        self._observers = []\n\n    def attach(self, observer):\n        &quot;&quot;&quot;\n        注册一个观察者\n        &quot;&quot;&quot;\n        if observer not in self._observers:\n            self._observers.append(observer)\n\n    def detach(self, observer):\n        &quot;&quot;&quot;\n        注销一个观察者\n        &quot;&quot;&quot;\n        try:\n            self._observers.remove(observer)\n        except ValueError:\n            pass\n\n    def notify(self):\n        &quot;&quot;&quot;\n        通知所有观察者，执行观察者的更新方法\n        &quot;&quot;&quot;\n        for observer in self._observers:\n            observer.update(self)\n\n\nclass Course(Subject):\n    &quot;&quot;&quot;\n    课程对象，被观察的对象\n    &quot;&quot;&quot;\n\n    def __init__(self):\n        super(Course, self).__init__()\n        self._message = None\n\n    @property\n    def message(self):\n        &quot;&quot;&quot;\n        message 是一个属性\n        &quot;&quot;&quot;\n        return self._message\n\n    @message.setter\n    def message(self, msg):\n        &quot;&quot;&quot;\n        message 属性设置器\n        &quot;&quot;&quot;\n        self._message = msg\n        self.notify()\n\n\nclass Observer(object):\n    &quot;&quot;&quot;\n    观察者抽象类\n    &quot;&quot;&quot;\n\n    __metaclass__ = abc.ABCMeta\n\n    @abc.abstractmethod\n    def update(self, subject):\n        pass\n\n\nclass UserObserver(Observer):\n    &quot;&quot;&quot;\n    用户观察者\n    &quot;&quot;&quot;\n\n    def update(self, subject):\n        print(&quot;User observer: %s&quot; % subject.message)\n\n\nclass OrgObserver(Observer):\n    &quot;&quot;&quot;\n    机构观察者\n    &quot;&quot;&quot;\n\n    def update(self, subject):\n        print(&quot;Organization observer: %s&quot; % subject.message)\n\n\nif __name__ == &#39;__main__&#39;:\n    # 初始化一个用户观察者\n    user = UserObserver()\n    # 初始化一个机构观察者\n    org = OrgObserver()\n\n    # 初始化一个课程\n    course = Course()\n    # 注册观察者\n    course.attach(user)\n    course.attach(org)\n\n    # 设置course.message，这时观察者会收到通知\n    course.message = &quot;two observers&quot;\n\n    # 注销一个观察者\n    course.detach(user)\n    course.message = &quot;single observer&quot;</code></pre>\n<ul>\n<li>Subject类，它实现了观察者模式中大部分功能。\n<ul>\n<li>作为一个被观察的对象，Subject实现了注册观察者，注销观察者和通知观察者的功能。</li>\n<li>接着我们基于Subject创建了我们的课程Course类，并且当我们设置Course.message属性时，Course对象会通知到所有观察者。</li>\n</ul></li>\n<li>可以看出，观察者模式使被观察的对象（主题）和观察者之间解耦了</li>\n</ul>\n<h3 id=\"命令模式-command\">命令模式 Command</h3>\n<p>命令模式就是对命令的封装。 -\n所谓封装命令，就是将一系列操作封装到命令类中，并且命令类只需要对外公开一个执行方法execute，调用此命令的对象只需要执行命令的execute方法就可以完成所有的操作。\n- 这样调用此命令的对象就和命令具体操作之间解耦了。 -\n更进一步，通过命令模式我们可以抽象出调用者，接收者和命令三个对象。 -\n调用者就是简单的调用命令，然后将命令发送给接收者，而接收者则接收并执行命令，执行命令的方式也是简单的调用命令的execute方法就可以了。\n-\n发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\nimport abc\n\n\nclass VmReceiver(object):\n    &quot;&quot;&quot;\n    命令接收者，真正执行命令的地方\n    &quot;&quot;&quot;\n\n    def start(self):\n        print(&quot;Virtual machine start&quot;)\n\n    def stop(self):\n        print(&quot;Virtual machine stop&quot;)\n\n\nclass Command(object):\n    &quot;&quot;&quot;\n    命令抽象类\n    &quot;&quot;&quot;\n    __metaclass__ = abc.ABCMeta\n\n    @abc.abstractmethod\n    def execute(self):\n        &quot;&quot;&quot;\n        命令对象对外只提供 execute 方法\n        &quot;&quot;&quot;\n        pass\n\n\nclass StartVmCommand(Command):\n    &quot;&quot;&quot;\n    开启虚拟机的命令\n    &quot;&quot;&quot;\n\n    def __init__(self, recevier):\n        &quot;&quot;&quot;\n        使用一个命令接收者初始化\n        &quot;&quot;&quot;\n        self.recevier = recevier\n\n    def execute(self):\n        &quot;&quot;&quot;\n        真正执行命令的时候命令接收者开启虚拟机\n        &quot;&quot;&quot;\n        self.recevier.start()\n\n\nclass StopVmCommand(Command):\n    &quot;&quot;&quot;\n    停止虚拟机的命令\n    &quot;&quot;&quot;\n\n    def __init__(self, recevier):\n        &quot;&quot;&quot;\n        使用一个命令接收者初始化\n        &quot;&quot;&quot;\n        self.recevier = recevier\n\n    def execute(self):\n        &quot;&quot;&quot;\n        真正执行命令的时候命令接收者关闭虚拟机\n        &quot;&quot;&quot;\n        self.recevier.stop()\n\n\nclass ClientInvoker(object):\n    &quot;&quot;&quot;\n    命令调用者\n    &quot;&quot;&quot;\n\n    def __init__(self, command):\n        self.command = command\n\n    def do(self):\n        self.command.execute()\n\n\nif __name__ == &#39;__main__&#39;:\n    recevier = VmReceiver()\n    start_command = StartVmCommand(recevier)\n    # 命令调用者同时也是客户端，通过命令实例也执行真正的操作\n    client = ClientInvoker(start_command)\n    client.do()\n\n    # 能告诉命令接收者执行不同的操作\n    stop_command = StopVmCommand(recevier)\n    client.command = stop_command\n    client.do()</code></pre>\n<p>命令模式的封装性很好：每个命令都被封装起来，对于客户端来说，需要什么功能就去调用相应的命令，而无需知道命令具体是怎么执行的。同时命令模式的扩展性很好，在命令模式中，在接收者类中一般会对操作进行最基本的封装，命令类则通过对这些基本的操作进行二次封装，当增加新命令的时候，对命令类的编写一般不是从零开始的，有大量的接收者类可供调用，也有大量的命令类可供调用，代码的复用性很好</p>\n<h3 id=\"模板方法模式-template-method\">模板方法模式 template method</h3>\n<p>在模板方法模式中，我们先定义一个类模板，在这个类中，我们定义了各种操作的顺序（轮毂或者说是骨架），但是并不实现这些操作，这些操作由子类来操作。</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\nimport abc\n\n\nclass Fishing(object):\n    &quot;&quot;&quot;\n    钓鱼模板基类\n    &quot;&quot;&quot;\n    __metaclass__ = abc.ABCMeta\n\n    def finishing(self):\n        &quot;&quot;&quot;\n        钓鱼方法中，确定了要执行哪些操作才能钓鱼\n        &quot;&quot;&quot;\n        self.prepare_bait()\n        self.go_to_riverbank()\n        self.find_location()\n        print(&quot;start fishing&quot;)\n\n    @abc.abstractmethod\n    def prepare_bait(self):\n        pass\n\n    @abc.abstractmethod\n    def go_to_riverbank(self):\n        pass\n\n    @abc.abstractmethod\n    def find_location(self):\n        pass\n\n\nclass JohnFishing(Fishing):\n    &quot;&quot;&quot;\n    John 也想去钓鱼，它必须实现钓鱼三步骤\n    &quot;&quot;&quot;\n\n    def prepare_bait(self):\n        &quot;&quot;&quot;\n        从淘宝购买鱼饵\n        &quot;&quot;&quot;\n        print(&quot;John: buy bait from Taobao&quot;)\n\n    def go_to_riverbank(self):\n        &quot;&quot;&quot;\n        开车去钓鱼\n        &quot;&quot;&quot;\n        print(&quot;John: to river by driving&quot;)\n\n    def find_location(self):\n        &quot;&quot;&quot;\n        在岛上选择钓点\n        &quot;&quot;&quot;\n        print(&quot;John: select location on the island&quot;)\n\n\nclass SimonFishing(Fishing):\n    &quot;&quot;&quot;\n    Simon 也想去钓鱼，它也必须实现钓鱼三步骤\n    &quot;&quot;&quot;\n\n    def prepare_bait(self):\n        &quot;&quot;&quot;\n        从京东购买鱼饵\n        &quot;&quot;&quot;\n        print(&quot;Simon: buy bait from JD&quot;)\n\n    def go_to_riverbank(self):\n        &quot;&quot;&quot;\n        骑自行车去钓鱼\n        &quot;&quot;&quot;\n        print(&quot;Simon: to river by biking&quot;)\n\n    def find_location(self):\n        &quot;&quot;&quot;\n        在河边选择钓点\n        &quot;&quot;&quot;\n        print(&quot;Simon: select location on the riverbank&quot;)\n\n\nif __name__ == &#39;__main__&#39;:\n    # John 去钓鱼\n    f = JohnFishing()\n    f.finishing()\n\n    # Simon 去钓鱼\n    f = SimonFishing()\n    f.finishing()</code></pre>\n<p><strong>模板方法模式是结构最简单的行为型设计模式，在其结构中只存在父类与子类之间的继承关系。</strong>\n-\n通过使用模板方法模式，可以将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供一个称之为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。\n-\n模板方法模式提供了一个模板方法来定义算法框架，而某些具体步骤的实现可以在其子类中完成</p>\n<hr>\n<h3 id=\"about-me\">About ME</h3>\n<h5 id=\"读书城南-在未来面前我们都是孩子\">👋 读书城南，🤔\n在未来面前，我们都是孩子～</h5>\n<ul>\n<li>📙\n一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~</li>\n</ul>\n<h5 id=\"social-media\">👋 Social Media</h5>\n<ul>\n<li><p>🛠️ Blog: <a href=\"http://oceaneyes.top\">http://oceaneyes.top</a></p></li>\n<li><p>⚡ PM导航: <a href=\"https://pmhub.oceangzy.top\">https://pmhub.oceangzy.top</a></p></li>\n<li><p>☘️ CNBLOG: <a href=\"https://www.cnblogs.com/oceaneyes-gzy/\">https://www.cnblogs.com/oceaneyes-gzy/</a></p></li>\n<li><p>🌱 AI PRJ自己部署的一些算法demo: <a href=\"http://ai.oceangzy.top/\">http://ai.oceangzy.top/</a></p></li>\n<li><p>📫 Email: 1450136519@qq.com</p></li>\n<li><p>💬 WeChat: <a href=\"https://oceaneyes.top/img/wechatqrcode.jpg\">OCEANGZY</a></p></li>\n<li><p>💬 公众号: <a href=\"https://oceaneyes.top/img/wechatgzh.jpeg\">UncleJoker-GZY</a></p></li>\n</ul>\n<h5 id=\"加入小组\">👋 加入小组~</h5>\n<p><img src=\"https://oceaneyes.top/img/zhishigroup.jpg\" title=\"加入组织\" alt width=\"240\"></p>\n<h5 id=\"感谢打赏\">👋 感谢打赏~</h5>\n<p><img src=\"https://oceaneyes.top/img/alipay.jpg\" title=\"支付宝打赏\" alt width=\"140\">\n<img src=\"https://oceaneyes.top/img/wechatpay.jpg\" title=\"微信打赏\" alt width=\"140\"></p>\n","more":"<h2 id=\"python设计模式-行为型策略模式观察者模式命令模式模板方法\">Python设计模式-行为型：策略模式,观察者模式,命令模式,模板方法</h2>\n<blockquote>\n<p>行为型模式会涉及到算法和对象间的职责分配，不仅描述对象或类的模式，还描述它们之间的通信方式，刻划了运行时难以跟踪的复杂的控制流，它们将你的注意力从控制流转移到对象间的关系上来。</p>\n</blockquote>\n<ul>\n<li>策略模式定义及简单实现案例</li>\n<li>观察者模式定义及简单实现案例</li>\n<li>命令模式定义及简单实现案例</li>\n<li>模板方法模式定义及简单实现案例</li>\n</ul>\n<h3 id=\"策略模式-strategy\">策略模式 strategy</h3>\n<pre><code>case:一个问题可能有多种显示方式。如果用户有管理权限，那么问题的详情页面可能会显示编辑按钮，如果是普通用户则只显示问题内容。这样一个对象我们该怎么实现呢</code></pre>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\nclass Question(object):\n    &quot;&quot;&quot;\n    问题对象，没有使用策略模式之前的作法\n    &quot;&quot;&quot;\n\n    def __init__(self, admin=True):\n        self._admin = admin\n\n    def show(self):\n        &quot;&quot;&quot;\n        根据是否是管理员显示不同的信息\n        &quot;&quot;&quot;\n        if self._admin is True:\n            return &quot;show page with admin&quot;\n        else:\n            return &quot;show page with user&quot;\n\n\nif __name__ == &#39;__main__&#39;:\n    q = Question(admin=False)\n    print(q.show())</code></pre>\n<p>以上代码中，最重要的操作就是Question.show操作，它会根据Quesiton._admin标志的不同完成两种显示。</p>\n<p>现在我们有一些新的需求，增加Question的显示方式，怎么办？ -\n如果增加更多的显示方式，按照以上作法，我们必然要修改Quesiton.show方法，并增加更多的标志位。\n-\n这样一来Question在面对不断增加的显示需求时都需要修改其代码，显然这是一种不好的设计。</p>\n<p>下面该轮到策略模式发挥作用的时候了，策略模式将各种操作（算法）进行封装，并使它们之间可以互换。互换的意思是说可以动态改变对象的操作方式（算法）。</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\nimport abc\n\n\nclass AbsShow(object):\n    &quot;&quot;&quot;\n    抽象显示对象\n    &quot;&quot;&quot;\n\n    __metaclass__ = abc.ABCMeta\n\n    @abc.abstractmethod\n    def show(self):\n        pass\n\n\nclass AdminShow(AbsShow):\n    &quot;&quot;&quot;\n    管理员的显示操作\n    &quot;&quot;&quot;\n\n    def show(self):\n        return &quot;show with admin&quot;\n\n\nclass UserShow(AbsShow):\n    &quot;&quot;&quot;\n    普通用户的显示操作\n    &quot;&quot;&quot;\n\n    def show(self):\n        return &quot;show with user&quot;\n\n\nclass Question(object):\n    &quot;&quot;&quot;\n    问题对象，使用策略模式之后的作法\n    &quot;&quot;&quot;\n\n    def __init__(self, show_obj):\n        self.show_obj = show_obj\n\n    def show(self):\n        return self.show_obj.show()\n\n\n\nif __name__ == &#39;__main__&#39;:\n    q = Question(show_obj=AdminShow())\n    print(q.show())\n    # 替换原来的显示对象，体现了策略模式的互换行为\n    q.show_obj = UserShow()\n    print(q.show())</code></pre>\n<p>将 Question\n对象和显示方法进行了解耦，增加新的显示方法时，只需要增加新的显示对象就可以了。同时，在代码中还可以看到我们可以动态改变\nQuestion 的显示方式，这也体现了策略模式的互换行为。</p>\n<h3 id=\"观察者模式-observer\">观察者模式 Observer</h3>\n<p>所谓观察者模式，就是说当一个对象发生变化时，观察者能及时得到通知并更新</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\nimport abc\n\n\nclass Subject(object):\n    &quot;&quot;&quot;\n    被观察对象的基类\n    &quot;&quot;&quot;\n\n    def __init__(self):\n        self._observers = []\n\n    def attach(self, observer):\n        &quot;&quot;&quot;\n        注册一个观察者\n        &quot;&quot;&quot;\n        if observer not in self._observers:\n            self._observers.append(observer)\n\n    def detach(self, observer):\n        &quot;&quot;&quot;\n        注销一个观察者\n        &quot;&quot;&quot;\n        try:\n            self._observers.remove(observer)\n        except ValueError:\n            pass\n\n    def notify(self):\n        &quot;&quot;&quot;\n        通知所有观察者，执行观察者的更新方法\n        &quot;&quot;&quot;\n        for observer in self._observers:\n            observer.update(self)\n\n\nclass Course(Subject):\n    &quot;&quot;&quot;\n    课程对象，被观察的对象\n    &quot;&quot;&quot;\n\n    def __init__(self):\n        super(Course, self).__init__()\n        self._message = None\n\n    @property\n    def message(self):\n        &quot;&quot;&quot;\n        message 是一个属性\n        &quot;&quot;&quot;\n        return self._message\n\n    @message.setter\n    def message(self, msg):\n        &quot;&quot;&quot;\n        message 属性设置器\n        &quot;&quot;&quot;\n        self._message = msg\n        self.notify()\n\n\nclass Observer(object):\n    &quot;&quot;&quot;\n    观察者抽象类\n    &quot;&quot;&quot;\n\n    __metaclass__ = abc.ABCMeta\n\n    @abc.abstractmethod\n    def update(self, subject):\n        pass\n\n\nclass UserObserver(Observer):\n    &quot;&quot;&quot;\n    用户观察者\n    &quot;&quot;&quot;\n\n    def update(self, subject):\n        print(&quot;User observer: %s&quot; % subject.message)\n\n\nclass OrgObserver(Observer):\n    &quot;&quot;&quot;\n    机构观察者\n    &quot;&quot;&quot;\n\n    def update(self, subject):\n        print(&quot;Organization observer: %s&quot; % subject.message)\n\n\nif __name__ == &#39;__main__&#39;:\n    # 初始化一个用户观察者\n    user = UserObserver()\n    # 初始化一个机构观察者\n    org = OrgObserver()\n\n    # 初始化一个课程\n    course = Course()\n    # 注册观察者\n    course.attach(user)\n    course.attach(org)\n\n    # 设置course.message，这时观察者会收到通知\n    course.message = &quot;two observers&quot;\n\n    # 注销一个观察者\n    course.detach(user)\n    course.message = &quot;single observer&quot;</code></pre>\n<ul>\n<li>Subject类，它实现了观察者模式中大部分功能。\n<ul>\n<li>作为一个被观察的对象，Subject实现了注册观察者，注销观察者和通知观察者的功能。</li>\n<li>接着我们基于Subject创建了我们的课程Course类，并且当我们设置Course.message属性时，Course对象会通知到所有观察者。</li>\n</ul></li>\n<li>可以看出，观察者模式使被观察的对象（主题）和观察者之间解耦了</li>\n</ul>\n<h3 id=\"命令模式-command\">命令模式 Command</h3>\n<p>命令模式就是对命令的封装。 -\n所谓封装命令，就是将一系列操作封装到命令类中，并且命令类只需要对外公开一个执行方法execute，调用此命令的对象只需要执行命令的execute方法就可以完成所有的操作。\n- 这样调用此命令的对象就和命令具体操作之间解耦了。 -\n更进一步，通过命令模式我们可以抽象出调用者，接收者和命令三个对象。 -\n调用者就是简单的调用命令，然后将命令发送给接收者，而接收者则接收并执行命令，执行命令的方式也是简单的调用命令的execute方法就可以了。\n-\n发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\nimport abc\n\n\nclass VmReceiver(object):\n    &quot;&quot;&quot;\n    命令接收者，真正执行命令的地方\n    &quot;&quot;&quot;\n\n    def start(self):\n        print(&quot;Virtual machine start&quot;)\n\n    def stop(self):\n        print(&quot;Virtual machine stop&quot;)\n\n\nclass Command(object):\n    &quot;&quot;&quot;\n    命令抽象类\n    &quot;&quot;&quot;\n    __metaclass__ = abc.ABCMeta\n\n    @abc.abstractmethod\n    def execute(self):\n        &quot;&quot;&quot;\n        命令对象对外只提供 execute 方法\n        &quot;&quot;&quot;\n        pass\n\n\nclass StartVmCommand(Command):\n    &quot;&quot;&quot;\n    开启虚拟机的命令\n    &quot;&quot;&quot;\n\n    def __init__(self, recevier):\n        &quot;&quot;&quot;\n        使用一个命令接收者初始化\n        &quot;&quot;&quot;\n        self.recevier = recevier\n\n    def execute(self):\n        &quot;&quot;&quot;\n        真正执行命令的时候命令接收者开启虚拟机\n        &quot;&quot;&quot;\n        self.recevier.start()\n\n\nclass StopVmCommand(Command):\n    &quot;&quot;&quot;\n    停止虚拟机的命令\n    &quot;&quot;&quot;\n\n    def __init__(self, recevier):\n        &quot;&quot;&quot;\n        使用一个命令接收者初始化\n        &quot;&quot;&quot;\n        self.recevier = recevier\n\n    def execute(self):\n        &quot;&quot;&quot;\n        真正执行命令的时候命令接收者关闭虚拟机\n        &quot;&quot;&quot;\n        self.recevier.stop()\n\n\nclass ClientInvoker(object):\n    &quot;&quot;&quot;\n    命令调用者\n    &quot;&quot;&quot;\n\n    def __init__(self, command):\n        self.command = command\n\n    def do(self):\n        self.command.execute()\n\n\nif __name__ == &#39;__main__&#39;:\n    recevier = VmReceiver()\n    start_command = StartVmCommand(recevier)\n    # 命令调用者同时也是客户端，通过命令实例也执行真正的操作\n    client = ClientInvoker(start_command)\n    client.do()\n\n    # 能告诉命令接收者执行不同的操作\n    stop_command = StopVmCommand(recevier)\n    client.command = stop_command\n    client.do()</code></pre>\n<p>命令模式的封装性很好：每个命令都被封装起来，对于客户端来说，需要什么功能就去调用相应的命令，而无需知道命令具体是怎么执行的。同时命令模式的扩展性很好，在命令模式中，在接收者类中一般会对操作进行最基本的封装，命令类则通过对这些基本的操作进行二次封装，当增加新命令的时候，对命令类的编写一般不是从零开始的，有大量的接收者类可供调用，也有大量的命令类可供调用，代码的复用性很好</p>\n<h3 id=\"模板方法模式-template-method\">模板方法模式 template method</h3>\n<p>在模板方法模式中，我们先定义一个类模板，在这个类中，我们定义了各种操作的顺序（轮毂或者说是骨架），但是并不实现这些操作，这些操作由子类来操作。</p>\n<pre class=\"python3\"><code># -*- coding: utf-8 -*-\n\nimport abc\n\n\nclass Fishing(object):\n    &quot;&quot;&quot;\n    钓鱼模板基类\n    &quot;&quot;&quot;\n    __metaclass__ = abc.ABCMeta\n\n    def finishing(self):\n        &quot;&quot;&quot;\n        钓鱼方法中，确定了要执行哪些操作才能钓鱼\n        &quot;&quot;&quot;\n        self.prepare_bait()\n        self.go_to_riverbank()\n        self.find_location()\n        print(&quot;start fishing&quot;)\n\n    @abc.abstractmethod\n    def prepare_bait(self):\n        pass\n\n    @abc.abstractmethod\n    def go_to_riverbank(self):\n        pass\n\n    @abc.abstractmethod\n    def find_location(self):\n        pass\n\n\nclass JohnFishing(Fishing):\n    &quot;&quot;&quot;\n    John 也想去钓鱼，它必须实现钓鱼三步骤\n    &quot;&quot;&quot;\n\n    def prepare_bait(self):\n        &quot;&quot;&quot;\n        从淘宝购买鱼饵\n        &quot;&quot;&quot;\n        print(&quot;John: buy bait from Taobao&quot;)\n\n    def go_to_riverbank(self):\n        &quot;&quot;&quot;\n        开车去钓鱼\n        &quot;&quot;&quot;\n        print(&quot;John: to river by driving&quot;)\n\n    def find_location(self):\n        &quot;&quot;&quot;\n        在岛上选择钓点\n        &quot;&quot;&quot;\n        print(&quot;John: select location on the island&quot;)\n\n\nclass SimonFishing(Fishing):\n    &quot;&quot;&quot;\n    Simon 也想去钓鱼，它也必须实现钓鱼三步骤\n    &quot;&quot;&quot;\n\n    def prepare_bait(self):\n        &quot;&quot;&quot;\n        从京东购买鱼饵\n        &quot;&quot;&quot;\n        print(&quot;Simon: buy bait from JD&quot;)\n\n    def go_to_riverbank(self):\n        &quot;&quot;&quot;\n        骑自行车去钓鱼\n        &quot;&quot;&quot;\n        print(&quot;Simon: to river by biking&quot;)\n\n    def find_location(self):\n        &quot;&quot;&quot;\n        在河边选择钓点\n        &quot;&quot;&quot;\n        print(&quot;Simon: select location on the riverbank&quot;)\n\n\nif __name__ == &#39;__main__&#39;:\n    # John 去钓鱼\n    f = JohnFishing()\n    f.finishing()\n\n    # Simon 去钓鱼\n    f = SimonFishing()\n    f.finishing()</code></pre>\n<p><strong>模板方法模式是结构最简单的行为型设计模式，在其结构中只存在父类与子类之间的继承关系。</strong>\n-\n通过使用模板方法模式，可以将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供一个称之为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。\n-\n模板方法模式提供了一个模板方法来定义算法框架，而某些具体步骤的实现可以在其子类中完成</p>\n<hr>\n<h3 id=\"about-me\">About ME</h3>\n<h5 id=\"读书城南-在未来面前我们都是孩子\">👋 读书城南，🤔\n在未来面前，我们都是孩子～</h5>\n<ul>\n<li>📙\n一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~</li>\n</ul>\n<h5 id=\"social-media\">👋 Social Media</h5>\n<ul>\n<li><p>🛠️ Blog: <a href=\"http://oceaneyes.top\">http://oceaneyes.top</a></p></li>\n<li><p>⚡ PM导航: <a href=\"https://pmhub.oceangzy.top\">https://pmhub.oceangzy.top</a></p></li>\n<li><p>☘️ CNBLOG: <a href=\"https://www.cnblogs.com/oceaneyes-gzy/\">https://www.cnblogs.com/oceaneyes-gzy/</a></p></li>\n<li><p>🌱 AI PRJ自己部署的一些算法demo: <a href=\"http://ai.oceangzy.top/\">http://ai.oceangzy.top/</a></p></li>\n<li><p>📫 Email: 1450136519@qq.com</p></li>\n<li><p>💬 WeChat: <a href=\"https://oceaneyes.top/img/wechatqrcode.jpg\">OCEANGZY</a></p></li>\n<li><p>💬 公众号: <a href=\"https://oceaneyes.top/img/wechatgzh.jpeg\">UncleJoker-GZY</a></p></li>\n</ul>\n<h5 id=\"加入小组\">👋 加入小组~</h5>\n<p><img src=\"https://oceaneyes.top/img/zhishigroup.jpg\" title=\"加入组织\" alt width=\"240\"></p>\n<h5 id=\"感谢打赏\">👋 感谢打赏~</h5>\n<p><img src=\"https://oceaneyes.top/img/alipay.jpg\" title=\"支付宝打赏\" alt width=\"140\">\n<img src=\"https://oceaneyes.top/img/wechatpay.jpg\" title=\"微信打赏\" alt width=\"140\"></p>\n","categories":[{"name":"Python3","path":"api/categories/Python3.json"}],"tags":[{"name":"Python3","path":"api/tags/Python3.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}