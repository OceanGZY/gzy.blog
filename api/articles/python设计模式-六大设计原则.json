{"title":"Python设计模式-六大设计原则","slug":"python设计模式-六大设计原则","date":"2022-06-01T15:50:00.000Z","updated":"2022-09-30T06:56:37.180Z","comments":true,"path":"api/articles/python设计模式-六大设计原则.json","excerpt":null,"covers":["https://oceaneyes.top/img/zhishigroup.jpg","https://oceaneyes.top/img/alipay.jpg","https://oceaneyes.top/img/wechatpay.jpg"],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"python设计模式-六大设计原则\">Python设计模式-六大设计原则</h2>\n<h3 id=\"单一职责原则-single-responsibility-principle\">单一职责原则\n(Single Responsibility Principle)</h3>\n<p>顾名思义，单一职责的原则是说一个类只负责一项职责（操作）。如果一个类负责多个职责，其中一项职责发生变化就需要修改整个类，这可能会导致其他的职责运行错误。一个类，只应该有一个引起它变化的原因。</p>\n<p>其优点有：</p>\n<ul>\n<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li>\n<li>提高类的可读性，提高系统的可维护性；</li>\n<li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li>\n</ul>\n<h3 id=\"里氏替换原则-liskov-substitution-principle\">里氏替换原则 (Liskov\nSubstitution Principle)</h3>\n<p>里氏替换的意思是说所有引用基类的地方必须能透明地使用其子类的对象。这种情况在代码中随处可以，我们在类中使用基类进行定义，而在运行时使用子类对象，为了确保代码运行正常，在实现子类时要注意以下一些地方：</p>\n<ul>\n<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法；</li>\n<li>子类中可以增加自己特有的方法；</li>\n<li>当子类的方法重载父类的方法时，子类方法的输入参数要比父类方法的输入参数更宽松；</li>\n</ul>\n<h3 id=\"依赖倒置原则-dependence-inversion-principle\">依赖倒置原则\n(Dependence Inversion Principle)</h3>\n<p><strong>定义</strong>：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。依赖倒置原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。在编写代码中落到实处，需要注意以下一些地方：</p>\n<p>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备； -\n变量的表名类型尽量是接口或者抽象类； - 尽量不要覆写基类的方法； -\n结合里氏替换原则使用。</p>\n<p>由于 Python\n是一门动态语言，在传递参数时不需要定义具体类型，所以依赖倒置原则其实一定程度上已经内嵌在了\nPython 语言中。</p>\n<h3 id=\"接口隔离原则-interface-segregation-principle\">接口隔离原则\n(Interface Segregation Principle)</h3>\n<p>接口隔离原则提示我们客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。</p>\n<p>看到这里你们或许认为接口隔离原则与单一职责原则是相同的。其实接口隔离原则与单一职责原则的审视角度是不相同的，单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。</p>\n<h3 id=\"迪米特原则-law-of-demeter\">迪米特原则 (Law of Demeter)</h3>\n<p><strong>定义</strong>：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的公开方法，我就调用这么多，其他的我一概不关心。迪米特法则指导我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。可以看到迪米特原则在代理模式和外观模式中都有被使用。</p>\n<h3 id=\"开闭原则-open-closed-principle\">开闭原则 (Open Closed\nPrinciple)</h3>\n<p>软件实体应该对扩展开放，对修改关闭，其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。根据开闭原则，在设计一个软件系统模块（类，方法）的时候，应该可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。遵循开闭原则的系统设计，可以让软件系统可复用，并且易于维护。这也是系统设计需要遵循开闭原则的原因：</p>\n<ul>\n<li>稳定性：开闭原则要求扩展功能不修改原来的代码，这可以让软件系统在变化中保持稳定。</li>\n<li>扩展性：开闭原则要求对扩展开放，通过扩展提供新的或改变原有的功能，让软件系统具有灵活的可扩展性。</li>\n</ul>\n<hr>\n<h3 id=\"about-me\">About ME</h3>\n<h5 id=\"读书城南-在未来面前我们都是孩子\">👋 读书城南，🤔\n在未来面前，我们都是孩子～</h5>\n<ul>\n<li>📙\n一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~</li>\n</ul>\n<h5 id=\"social-media\">👋 Social Media</h5>\n<ul>\n<li><p>🛠️ Blog: <a href=\"http://oceaneyes.top\">http://oceaneyes.top</a></p></li>\n<li><p>⚡ PM导航: <a href=\"https://pmhub.oceangzy.top\">https://pmhub.oceangzy.top</a></p></li>\n<li><p>☘️ CNBLOG: <a href=\"https://www.cnblogs.com/oceaneyes-gzy/\">https://www.cnblogs.com/oceaneyes-gzy/</a></p></li>\n<li><p>🌱 AI PRJ自己部署的一些算法demo: <a href=\"http://ai.oceangzy.top/\">http://ai.oceangzy.top/</a></p></li>\n<li><p>📫 Email: 1450136519@qq.com</p></li>\n<li><p>💬 WeChat: <a href=\"https://oceaneyes.top/img/wechatqrcode.jpg\">OCEANGZY</a></p></li>\n<li><p>💬 公众号: <a href=\"https://oceaneyes.top/img/wechatgzh.jpeg\">UncleJoker-GZY</a></p></li>\n</ul>\n<h5 id=\"加入小组\">👋 加入小组~</h5>\n<p><img src=\"https://oceaneyes.top/img/zhishigroup.jpg\" title=\"加入组织\" alt width=\"240\"></p>\n<h5 id=\"感谢打赏\">👋 感谢打赏~</h5>\n<p><img src=\"https://oceaneyes.top/img/alipay.jpg\" title=\"支付宝打赏\" alt width=\"140\">\n<img src=\"https://oceaneyes.top/img/wechatpay.jpg\" title=\"微信打赏\" alt width=\"140\"></p>\n","more":"<h2 id=\"python设计模式-六大设计原则\">Python设计模式-六大设计原则</h2>\n<h3 id=\"单一职责原则-single-responsibility-principle\">单一职责原则\n(Single Responsibility Principle)</h3>\n<p>顾名思义，单一职责的原则是说一个类只负责一项职责（操作）。如果一个类负责多个职责，其中一项职责发生变化就需要修改整个类，这可能会导致其他的职责运行错误。一个类，只应该有一个引起它变化的原因。</p>\n<p>其优点有：</p>\n<ul>\n<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li>\n<li>提高类的可读性，提高系统的可维护性；</li>\n<li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li>\n</ul>\n<h3 id=\"里氏替换原则-liskov-substitution-principle\">里氏替换原则 (Liskov\nSubstitution Principle)</h3>\n<p>里氏替换的意思是说所有引用基类的地方必须能透明地使用其子类的对象。这种情况在代码中随处可以，我们在类中使用基类进行定义，而在运行时使用子类对象，为了确保代码运行正常，在实现子类时要注意以下一些地方：</p>\n<ul>\n<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法；</li>\n<li>子类中可以增加自己特有的方法；</li>\n<li>当子类的方法重载父类的方法时，子类方法的输入参数要比父类方法的输入参数更宽松；</li>\n</ul>\n<h3 id=\"依赖倒置原则-dependence-inversion-principle\">依赖倒置原则\n(Dependence Inversion Principle)</h3>\n<p><strong>定义</strong>：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。依赖倒置原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。在编写代码中落到实处，需要注意以下一些地方：</p>\n<p>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备； -\n变量的表名类型尽量是接口或者抽象类； - 尽量不要覆写基类的方法； -\n结合里氏替换原则使用。</p>\n<p>由于 Python\n是一门动态语言，在传递参数时不需要定义具体类型，所以依赖倒置原则其实一定程度上已经内嵌在了\nPython 语言中。</p>\n<h3 id=\"接口隔离原则-interface-segregation-principle\">接口隔离原则\n(Interface Segregation Principle)</h3>\n<p>接口隔离原则提示我们客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。</p>\n<p>看到这里你们或许认为接口隔离原则与单一职责原则是相同的。其实接口隔离原则与单一职责原则的审视角度是不相同的，单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。</p>\n<h3 id=\"迪米特原则-law-of-demeter\">迪米特原则 (Law of Demeter)</h3>\n<p><strong>定义</strong>：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的公开方法，我就调用这么多，其他的我一概不关心。迪米特法则指导我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。可以看到迪米特原则在代理模式和外观模式中都有被使用。</p>\n<h3 id=\"开闭原则-open-closed-principle\">开闭原则 (Open Closed\nPrinciple)</h3>\n<p>软件实体应该对扩展开放，对修改关闭，其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。根据开闭原则，在设计一个软件系统模块（类，方法）的时候，应该可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。遵循开闭原则的系统设计，可以让软件系统可复用，并且易于维护。这也是系统设计需要遵循开闭原则的原因：</p>\n<ul>\n<li>稳定性：开闭原则要求扩展功能不修改原来的代码，这可以让软件系统在变化中保持稳定。</li>\n<li>扩展性：开闭原则要求对扩展开放，通过扩展提供新的或改变原有的功能，让软件系统具有灵活的可扩展性。</li>\n</ul>\n<hr>\n<h3 id=\"about-me\">About ME</h3>\n<h5 id=\"读书城南-在未来面前我们都是孩子\">👋 读书城南，🤔\n在未来面前，我们都是孩子～</h5>\n<ul>\n<li>📙\n一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~</li>\n</ul>\n<h5 id=\"social-media\">👋 Social Media</h5>\n<ul>\n<li><p>🛠️ Blog: <a href=\"http://oceaneyes.top\">http://oceaneyes.top</a></p></li>\n<li><p>⚡ PM导航: <a href=\"https://pmhub.oceangzy.top\">https://pmhub.oceangzy.top</a></p></li>\n<li><p>☘️ CNBLOG: <a href=\"https://www.cnblogs.com/oceaneyes-gzy/\">https://www.cnblogs.com/oceaneyes-gzy/</a></p></li>\n<li><p>🌱 AI PRJ自己部署的一些算法demo: <a href=\"http://ai.oceangzy.top/\">http://ai.oceangzy.top/</a></p></li>\n<li><p>📫 Email: 1450136519@qq.com</p></li>\n<li><p>💬 WeChat: <a href=\"https://oceaneyes.top/img/wechatqrcode.jpg\">OCEANGZY</a></p></li>\n<li><p>💬 公众号: <a href=\"https://oceaneyes.top/img/wechatgzh.jpeg\">UncleJoker-GZY</a></p></li>\n</ul>\n<h5 id=\"加入小组\">👋 加入小组~</h5>\n<p><img src=\"https://oceaneyes.top/img/zhishigroup.jpg\" title=\"加入组织\" alt width=\"240\"></p>\n<h5 id=\"感谢打赏\">👋 感谢打赏~</h5>\n<p><img src=\"https://oceaneyes.top/img/alipay.jpg\" title=\"支付宝打赏\" alt width=\"140\">\n<img src=\"https://oceaneyes.top/img/wechatpay.jpg\" title=\"微信打赏\" alt width=\"140\"></p>\n","categories":[{"name":"Python3","path":"api/categories/Python3.json"}],"tags":[{"name":"Python3","path":"api/tags/Python3.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}