<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Bert-TF-2.6修改-自调适配版 | OCAEN.GZY读书城南</title><meta name="author" content="OCEAN.GZY"><meta name="copyright" content="OCEAN.GZY"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Bert-TF-2.6修改-自调适配版 背景 bert开源版适配的为tf1版本，当机器的tf环境为2以上版本时，会出现各种异常。 因此我根据tf的函数库，进行了bert适配tf2.6的修改适配。 代码 run_classifier.py from __future__ import absolute_import from __future__ import division from __fut">
<meta property="og:type" content="article">
<meta property="og:title" content="Bert-TF-2.6修改-自调适配版">
<meta property="og:url" content="http://oceangzy.top/2021/08/01/bert-tf2-6/index.html">
<meta property="og:site_name" content="OCAEN.GZY读书城南">
<meta property="og:description" content="Bert-TF-2.6修改-自调适配版 背景 bert开源版适配的为tf1版本，当机器的tf环境为2以上版本时，会出现各种异常。 因此我根据tf的函数库，进行了bert适配tf2.6的修改适配。 代码 run_classifier.py from __future__ import absolute_import from __future__ import division from __fut">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://oceangzy.top/img/avatar.png">
<meta property="article:published_time" content="2021-08-01T15:57:08.000Z">
<meta property="article:modified_time" content="2022-09-30T06:56:37.166Z">
<meta property="article:author" content="OCEAN.GZY">
<meta property="article:tag" content="Artificial Intelligence">
<meta property="article:tag" content="Bert">
<meta property="article:tag" content="Natural Language Processing">
<meta property="article:tag" content="Tensorflow 2.6">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://oceangzy.top/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://oceangzy.top/2021/08/01/bert-tf2-6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Bert-TF-2.6修改-自调适配版',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-30 14:56:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">167</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">116</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">94</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="OCAEN.GZY读书城南"></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Bert-TF-2.6修改-自调适配版</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-01T15:57:08.000Z" title="发表于 2021-08-01 23:57:08">2021-08-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-30T06:56:37.166Z" title="更新于 2022-09-30 14:56:37">2022-09-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Artificial-Intelligence/">Artificial Intelligence</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Artificial-Intelligence/Natural-Language-Processing/">Natural Language Processing</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Artificial-Intelligence/Natural-Language-Processing/Bert/">Bert</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Artificial-Intelligence/Natural-Language-Processing/Bert/Tensorflow-2-6/">Tensorflow 2.6</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Bert-TF-2.6修改-自调适配版"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="bert-tf-2.6修改-自调适配版">Bert-TF-2.6修改-自调适配版</h1>
<h4 id="背景">背景</h4>
<p>bert开源版适配的为tf1版本，当机器的tf环境为2以上版本时，会出现各种异常。</p>
<p>因此我根据tf的函数库，进行了bert适配tf2.6的修改适配。</p>
<h4 id="代码">代码</h4>
<h5 id="run_classifier.py">run_classifier.py</h5>
<pre class="python3"><code>from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import collections
import csv
import os
import modeling
import optimization
import tokenization
import tensorflow as tf
from absl import flags
from absl import app
import pickle

# flags = tf.flags

FLAGS = flags.FLAGS

## Required parameters
flags.DEFINE_string(
    &quot;data_dir&quot;, None,
    &quot;The input data dir. Should contain the .tsv files (or other data files) &quot;
    &quot;for the task.&quot;)

flags.DEFINE_string(
    &quot;bert_config_file&quot;, None,
    &quot;The config json file corresponding to the pre-trained BERT model. &quot;
    &quot;This specifies the model architecture.&quot;)

flags.DEFINE_string(&quot;task_name&quot;, None, &quot;The name of the task to train.&quot;)

flags.DEFINE_string(&quot;vocab_file&quot;, None,
                    &quot;The vocabulary file that the BERT model was trained on.&quot;)

flags.DEFINE_string(
    &quot;output_dir&quot;, None,
    &quot;The output directory where the model checkpoints will be written.&quot;)

flags.DEFINE_string(
    &quot;trans_model_dir&quot;, None,
    &quot;The trans_model_dir directory where the model will be written.&quot;)


## Other parameters

flags.DEFINE_string(
    &quot;init_checkpoint&quot;, None,
    &quot;Initial checkpoint (usually from a pre-trained BERT model).&quot;)

flags.DEFINE_bool(
    &quot;do_lower_case&quot;, True,
    &quot;Whether to lower case the input text. Should be True for uncased &quot;
    &quot;models and False for cased models.&quot;)

flags.DEFINE_integer(
    &quot;max_seq_length&quot;, 128,
    &quot;The maximum total input sequence length after WordPiece tokenization. &quot;
    &quot;Sequences longer than this will be truncated, and sequences shorter &quot;
    &quot;than this will be padded.&quot;)

flags.DEFINE_bool(&quot;do_train&quot;, False, &quot;Whether to run training.&quot;)

flags.DEFINE_bool(&quot;do_eval&quot;, False, &quot;Whether to run eval on the dev set.&quot;)

flags.DEFINE_bool(
    &quot;do_predict&quot;, False,
    &quot;Whether to run the model in inference mode on the test set.&quot;)

flags.DEFINE_integer(&quot;train_batch_size&quot;, 32, &quot;Total batch size for training.&quot;)

flags.DEFINE_integer(&quot;eval_batch_size&quot;, 8, &quot;Total batch size for eval.&quot;)

flags.DEFINE_integer(&quot;predict_batch_size&quot;, 8, &quot;Total batch size for predict.&quot;)

flags.DEFINE_float(&quot;learning_rate&quot;, 5e-5, &quot;The initial learning rate for Adam.&quot;)

flags.DEFINE_float(&quot;num_train_epochs&quot;, 3.0,
                   &quot;Total number of training epochs to perform.&quot;)

flags.DEFINE_float(
    &quot;warmup_proportion&quot;, 0.1,
    &quot;Proportion of training to perform linear learning rate warmup for. &quot;
    &quot;E.g., 0.1 = 10% of training.&quot;)

flags.DEFINE_integer(&quot;save_checkpoints_steps&quot;, 1000,
                     &quot;How often to save the model checkpoint.&quot;)

flags.DEFINE_integer(&quot;iterations_per_loop&quot;, 1000,
                     &quot;How many steps to make in each estimator call.&quot;)

flags.DEFINE_bool(&quot;use_tpu&quot;, False, &quot;Whether to use TPU or GPU/CPU.&quot;)

flags.DEFINE_string(
    &quot;tpu_name&quot;, None,
    &quot;The Cloud TPU to use for training. This should be either the name &quot;
    &quot;used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 &quot;
    &quot;url.&quot;)

flags.DEFINE_string(
    &quot;tpu_zone&quot;, None,
    &quot;[Optional] GCE zone where the Cloud TPU is located in. If not &quot;
    &quot;specified, we will attempt to automatically detect the GCE project from &quot;
    &quot;metadata.&quot;)

flags.DEFINE_string(
    &quot;gcp_project&quot;, None,
    &quot;[Optional] Project name for the Cloud TPU-enabled project. If not &quot;
    &quot;specified, we will attempt to automatically detect the GCE project from &quot;
    &quot;metadata.&quot;)

flags.DEFINE_string(&quot;master&quot;, None, &quot;[Optional] TensorFlow master URL.&quot;)

flags.DEFINE_integer(
    &quot;num_tpu_cores&quot;, 8,
    &quot;Only used if `use_tpu` is True. Total number of TPU cores to use.&quot;)


class InputExample(object):
  &quot;&quot;&quot;A single training/test example for simple sequence classification.&quot;&quot;&quot;

  def __init__(self, guid, text_a, text_b=None, label=None):
    &quot;&quot;&quot;Constructs a InputExample.

    Args:
      guid: Unique id for the example.
      text_a: string. The untokenized text of the first sequence. For single
        sequence tasks, only this sequence must be specified.
      text_b: (Optional) string. The untokenized text of the second sequence.
        Only must be specified for sequence pair tasks.
      label: (Optional) string. The label of the example. This should be
        specified for train and dev examples, but not for test examples.
    &quot;&quot;&quot;
    self.guid = guid
    self.text_a = text_a
    self.text_b = text_b
    self.label = label


class PaddingInputExample(object):
  &quot;&quot;&quot;Fake example so the num input examples is a multiple of the batch size.

  When running eval/predict on the TPU, we need to pad the number of examples
  to be a multiple of the batch size, because the TPU requires a fixed batch
  size. The alternative is to drop the last batch, which is bad because it means
  the entire output data won&#39;t be generated.

  We use this class instead of `None` because treating `None` as padding
  battches could cause silent errors.
  &quot;&quot;&quot;


class InputFeatures(object):
  &quot;&quot;&quot;A single set of features of data.&quot;&quot;&quot;

  def __init__(self,
               input_ids,
               input_mask,
               segment_ids,
               label_id,
               is_real_example=True):
    self.input_ids = input_ids
    self.input_mask = input_mask
    self.segment_ids = segment_ids
    self.label_id = label_id
    self.is_real_example = is_real_example


class DataProcessor(object):
  &quot;&quot;&quot;Base class for data converters for sequence classification data sets.&quot;&quot;&quot;

  def get_train_examples(self, data_dir):
    &quot;&quot;&quot;Gets a collection of `InputExample`s for the train set.&quot;&quot;&quot;
    raise NotImplementedError()

  def get_dev_examples(self, data_dir):
    &quot;&quot;&quot;Gets a collection of `InputExample`s for the dev set.&quot;&quot;&quot;
    raise NotImplementedError()

  def get_test_examples(self, data_dir):
    &quot;&quot;&quot;Gets a collection of `InputExample`s for prediction.&quot;&quot;&quot;
    raise NotImplementedError()

  def get_labels(self):
    &quot;&quot;&quot;Gets the list of labels for this data set.&quot;&quot;&quot;
    raise NotImplementedError()

  @classmethod
  def _read_tsv(cls, input_file, quotechar=None):
    &quot;&quot;&quot;Reads a tab separated value file.&quot;&quot;&quot;
    with tf.io.gfile.GFile(input_file, &quot;r&quot;) as f:
      reader = csv.reader(f, delimiter=&quot;\t&quot;, quotechar=quotechar)
      lines = []
      for line in reader:
        lines.append(line)
      return lines


class XnliProcessor(DataProcessor):
  &quot;&quot;&quot;Processor for the XNLI data set.&quot;&quot;&quot;

  def __init__(self):
    self.language = &quot;zh&quot;

  def get_train_examples(self, data_dir):
    &quot;&quot;&quot;See base class.&quot;&quot;&quot;
    lines = self._read_tsv(
        os.path.join(data_dir, &quot;multinli&quot;,
                     &quot;multinli.train.%s.tsv&quot; % self.language))
    examples = []
    for (i, line) in enumerate(lines):
      if i == 0:
        continue
      guid = &quot;train-%d&quot; % (i)
      text_a = tokenization.convert_to_unicode(line[0])
      text_b = tokenization.convert_to_unicode(line[1])
      label = tokenization.convert_to_unicode(line[2])
      if label == tokenization.convert_to_unicode(&quot;contradictory&quot;):
        label = tokenization.convert_to_unicode(&quot;contradiction&quot;)
      examples.append(
          InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))
    return examples

  def get_dev_examples(self, data_dir):
    &quot;&quot;&quot;See base class.&quot;&quot;&quot;
    lines = self._read_tsv(os.path.join(data_dir, &quot;xnli.dev.tsv&quot;))
    examples = []
    for (i, line) in enumerate(lines):
      if i == 0:
        continue
      guid = &quot;dev-%d&quot; % (i)
      language = tokenization.convert_to_unicode(line[0])
      if language != tokenization.convert_to_unicode(self.language):
        continue
      text_a = tokenization.convert_to_unicode(line[6])
      text_b = tokenization.convert_to_unicode(line[7])
      label = tokenization.convert_to_unicode(line[1])
      examples.append(
          InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))
    return examples

  def get_labels(self):
    &quot;&quot;&quot;See base class.&quot;&quot;&quot;
    return [&quot;contradiction&quot;, &quot;entailment&quot;, &quot;neutral&quot;]


class MnliProcessor(DataProcessor):
  &quot;&quot;&quot;Processor for the MultiNLI data set (GLUE version).&quot;&quot;&quot;

  def get_train_examples(self, data_dir):
    &quot;&quot;&quot;See base class.&quot;&quot;&quot;
    return self._create_examples(
        self._read_tsv(os.path.join(data_dir, &quot;train.tsv&quot;)), &quot;train&quot;)

  def get_dev_examples(self, data_dir):
    &quot;&quot;&quot;See base class.&quot;&quot;&quot;
    return self._create_examples(
        self._read_tsv(os.path.join(data_dir, &quot;dev_matched.tsv&quot;)),
        &quot;dev_matched&quot;)

  def get_test_examples(self, data_dir):
    &quot;&quot;&quot;See base class.&quot;&quot;&quot;
    return self._create_examples(
        self._read_tsv(os.path.join(data_dir, &quot;test_matched.tsv&quot;)), &quot;test&quot;)

  def get_labels(self):
    &quot;&quot;&quot;See base class.&quot;&quot;&quot;
    return [&quot;contradiction&quot;, &quot;entailment&quot;, &quot;neutral&quot;]

  def _create_examples(self, lines, set_type):
    &quot;&quot;&quot;Creates examples for the training and dev sets.&quot;&quot;&quot;
    examples = []
    for (i, line) in enumerate(lines):
      if i == 0:
        continue
      guid = &quot;%s-%s&quot; % (set_type, tokenization.convert_to_unicode(line[0]))
      text_a = tokenization.convert_to_unicode(line[8])
      text_b = tokenization.convert_to_unicode(line[9])
      if set_type == &quot;test&quot;:
        label = &quot;contradiction&quot;
      else:
        label = tokenization.convert_to_unicode(line[-1])
      examples.append(
          InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))
    return examples


class MrpcProcessor(DataProcessor):
  &quot;&quot;&quot;Processor for the MRPC data set (GLUE version).&quot;&quot;&quot;

  def get_train_examples(self, data_dir):
    &quot;&quot;&quot;See base class.&quot;&quot;&quot;
    return self._create_examples(
        self._read_tsv(os.path.join(data_dir, &quot;train.tsv&quot;)), &quot;train&quot;)

  def get_dev_examples(self, data_dir):
    &quot;&quot;&quot;See base class.&quot;&quot;&quot;
    return self._create_examples(
        self._read_tsv(os.path.join(data_dir, &quot;dev.tsv&quot;)), &quot;dev&quot;)

  def get_test_examples(self, data_dir):
    &quot;&quot;&quot;See base class.&quot;&quot;&quot;
    return self._create_examples(
        self._read_tsv(os.path.join(data_dir, &quot;test.tsv&quot;)), &quot;test&quot;)

  def get_labels(self):
    &quot;&quot;&quot;See base class.&quot;&quot;&quot;
    return [&quot;0&quot;, &quot;1&quot;]

  def _create_examples(self, lines, set_type):
    &quot;&quot;&quot;Creates examples for the training and dev sets.&quot;&quot;&quot;
    examples = []
    for (i, line) in enumerate(lines):
      if i == 0:
        continue
      guid = &quot;%s-%s&quot; % (set_type, i)
      text_a = tokenization.convert_to_unicode(line[3])
      text_b = tokenization.convert_to_unicode(line[4])
      if set_type == &quot;test&quot;:
        label = &quot;0&quot;
      else:
        label = tokenization.convert_to_unicode(line[0])
      examples.append(
          InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))
    return examples


class ColaProcessor(DataProcessor):
  &quot;&quot;&quot;Processor for the CoLA data set (GLUE version).&quot;&quot;&quot;

  def get_train_examples(self, data_dir):
    &quot;&quot;&quot;See base class.&quot;&quot;&quot;
    return self._create_examples(
        self._read_tsv(os.path.join(data_dir, &quot;train.tsv&quot;)), &quot;train&quot;)

  def get_dev_examples(self, data_dir):
    &quot;&quot;&quot;See base class.&quot;&quot;&quot;
    return self._create_examples(
        self._read_tsv(os.path.join(data_dir, &quot;dev.tsv&quot;)), &quot;dev&quot;)

  def get_test_examples(self, data_dir):
    &quot;&quot;&quot;See base class.&quot;&quot;&quot;
    return self._create_examples(
        self._read_tsv(os.path.join(data_dir, &quot;test.tsv&quot;)), &quot;test&quot;)

  def get_labels(self):
    &quot;&quot;&quot;See base class.&quot;&quot;&quot;
    return [&quot;0&quot;, &quot;1&quot;]

  def _create_examples(self, lines, set_type):
    &quot;&quot;&quot;Creates examples for the training and dev sets.&quot;&quot;&quot;
    examples = []
    for (i, line) in enumerate(lines):
      # Only the test set has a header
      if set_type == &quot;test&quot; and i == 0:
        continue
      guid = &quot;%s-%s&quot; % (set_type, i)
      if set_type == &quot;test&quot;:
        text_a = tokenization.convert_to_unicode(line[1])
        label = &quot;0&quot;
      else:
        text_a = tokenization.convert_to_unicode(line[3])
        label = tokenization.convert_to_unicode(line[1])
      examples.append(
          InputExample(guid=guid, text_a=text_a, text_b=None, label=label))
    return examples


def convert_single_example(ex_index, example, label_list, max_seq_length,
                           tokenizer):
  &quot;&quot;&quot;Converts a single `InputExample` into a single `InputFeatures`.&quot;&quot;&quot;

  if isinstance(example, PaddingInputExample):
    return InputFeatures(
        input_ids=[0] * max_seq_length,
        input_mask=[0] * max_seq_length,
        segment_ids=[0] * max_seq_length,
        label_id=0,
        is_real_example=False)

  label_map = &#123;&#125;
  for (i, label) in enumerate(label_list):
    label_map[label] = i

  output_label2id_file = os.path.join(FLAGS.trans_model_dir, &quot;label2id.pkl&quot;)
  if not os.path.exists(output_label2id_file):
    with open(output_label2id_file, &#39;wb&#39;) as w:
        pickle.dump(label_map, w)

  tokens_a = tokenizer.tokenize(example.text_a)
  tokens_b = None
  if example.text_b:
    tokens_b = tokenizer.tokenize(example.text_b)

  if tokens_b:
    # Modifies `tokens_a` and `tokens_b` in place so that the total
    # length is less than the specified length.
    # Account for [CLS], [SEP], [SEP] with &quot;- 3&quot;
    _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)
  else:
    # Account for [CLS] and [SEP] with &quot;- 2&quot;
    if len(tokens_a) &gt; max_seq_length - 2:
      tokens_a = tokens_a[0:(max_seq_length - 2)]

  # The convention in BERT is:
  # (a) For sequence pairs:
  #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]
  #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1
  # (b) For single sequences:
  #  tokens:   [CLS] the dog is hairy . [SEP]
  #  type_ids: 0     0   0   0  0     0 0
  #
  # Where &quot;type_ids&quot; are used to indicate whether this is the first
  # sequence or the second sequence. The embedding vectors for `type=0` and
  # `type=1` were learned during pre-training and are added to the wordpiece
  # embedding vector (and position vector). This is not *strictly* necessary
  # since the [SEP] token unambiguously separates the sequences, but it makes
  # it easier for the model to learn the concept of sequences.
  #
  # For classification tasks, the first vector (corresponding to [CLS]) is
  # used as the &quot;sentence vector&quot;. Note that this only makes sense because
  # the entire model is fine-tuned.
  tokens = []
  segment_ids = []
  tokens.append(&quot;[CLS]&quot;)
  segment_ids.append(0)
  for token in tokens_a:
    tokens.append(token)
    segment_ids.append(0)
  tokens.append(&quot;[SEP]&quot;)
  segment_ids.append(0)

  if tokens_b:
    for token in tokens_b:
      tokens.append(token)
      segment_ids.append(1)
    tokens.append(&quot;[SEP]&quot;)
    segment_ids.append(1)

  input_ids = tokenizer.convert_tokens_to_ids(tokens)

  # The mask has 1 for real tokens and 0 for padding tokens. Only real
  # tokens are attended to.
  input_mask = [1] * len(input_ids)

  # Zero-pad up to the sequence length.
  while len(input_ids) &lt; max_seq_length:
    input_ids.append(0)
    input_mask.append(0)
    segment_ids.append(0)

  assert len(input_ids) == max_seq_length
  assert len(input_mask) == max_seq_length
  assert len(segment_ids) == max_seq_length

  label_id = label_map[example.label]
  if ex_index &lt; 5:
    tf.compat.v1.logging.info(&quot;*** Example ***&quot;)
    tf.compat.v1.logging.info(&quot;guid: %s&quot; % (example.guid))
    tf.compat.v1.logging.info(&quot;tokens: %s&quot; % &quot; &quot;.join(
        [tokenization.printable_text(x) for x in tokens]))
    tf.compat.v1.logging.info(&quot;input_ids: %s&quot; % &quot; &quot;.join([str(x) for x in input_ids]))
    tf.compat.v1.logging.info(&quot;input_mask: %s&quot; % &quot; &quot;.join([str(x) for x in input_mask]))
    tf.compat.v1.logging.info(&quot;segment_ids: %s&quot; % &quot; &quot;.join([str(x) for x in segment_ids]))
    tf.compat.v1.logging.info(&quot;label: %s (id = %d)&quot; % (example.label, label_id))

  feature = InputFeatures(
      input_ids=input_ids,
      input_mask=input_mask,
      segment_ids=segment_ids,
      label_id=label_id,
      is_real_example=True)
  return feature


def file_based_convert_examples_to_features(
    examples, label_list, max_seq_length, tokenizer, output_file):
  &quot;&quot;&quot;Convert a set of `InputExample`s to a TFRecord file.&quot;&quot;&quot;

  writer = tf.io.TFRecordWriter(output_file)

  for (ex_index, example) in enumerate(examples):
    if ex_index % 10000 == 0:
      tf.compat.v1.logging.info(&quot;Writing example %d of %d&quot; % (ex_index, len(examples)))

    feature = convert_single_example(ex_index, example, label_list,
                                     max_seq_length, tokenizer)

    def create_int_feature(values):
      f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))
      return f

    features = collections.OrderedDict()
    features[&quot;input_ids&quot;] = create_int_feature(feature.input_ids)
    features[&quot;input_mask&quot;] = create_int_feature(feature.input_mask)
    features[&quot;segment_ids&quot;] = create_int_feature(feature.segment_ids)
    features[&quot;label_ids&quot;] = create_int_feature([feature.label_id])
    features[&quot;is_real_example&quot;] = create_int_feature(
        [int(feature.is_real_example)])

    tf_example = tf.train.Example(features=tf.train.Features(feature=features))
    writer.write(tf_example.SerializeToString())
  writer.close()


def file_based_input_fn_builder(input_file, seq_length, is_training,
                                drop_remainder):
  &quot;&quot;&quot;Creates an `input_fn` closure to be passed to TPUEstimator.&quot;&quot;&quot;

  name_to_features = &#123;
      &quot;input_ids&quot;: tf.io.FixedLenFeature([seq_length], tf.int64),
      &quot;input_mask&quot;: tf.io.FixedLenFeature([seq_length], tf.int64),
      &quot;segment_ids&quot;: tf.io.FixedLenFeature([seq_length], tf.int64),
      &quot;label_ids&quot;: tf.io.FixedLenFeature([], tf.int64),
      &quot;is_real_example&quot;: tf.io.FixedLenFeature([], tf.int64),
  &#125;

  def _decode_record(record, name_to_features):
    &quot;&quot;&quot;Decodes a record to a TensorFlow example.&quot;&quot;&quot;
    example = tf.io.parse_single_example(record, name_to_features)

    # tf.Example only supports tf.int64, but the TPU only supports tf.int32.
    # So cast all int64 to int32.
    for name in list(example.keys()):
      t = example[name]
      if t.dtype == tf.int64:
        t = tf.compat.v1.to_int32(t)
      example[name] = t

    return example

  def input_fn(params):
    &quot;&quot;&quot;The actual input function.&quot;&quot;&quot;
    batch_size = params[&quot;batch_size&quot;]

    # For training, we want a lot of parallel reading and shuffling.
    # For eval, we want no shuffling and parallel reading doesn&#39;t matter.
    d = tf.data.TFRecordDataset(input_file)
    if is_training:
      d = d.repeat()
      d = d.shuffle(buffer_size=100)

    d = d.apply(
        tf.data.experimental.map_and_batch(
            lambda record: _decode_record(record, name_to_features),
            batch_size=batch_size,
            drop_remainder=drop_remainder))


    return d

  return input_fn


def _truncate_seq_pair(tokens_a, tokens_b, max_length):
  &quot;&quot;&quot;Truncates a sequence pair in place to the maximum length.&quot;&quot;&quot;

  # This is a simple heuristic which will always truncate the longer sequence
  # one token at a time. This makes more sense than truncating an equal percent
  # of tokens from each, since if one sequence is very short then each token
  # that&#39;s truncated likely contains more information than a longer sequence.
  while True:
    total_length = len(tokens_a) + len(tokens_b)
    if total_length &lt;= max_length:
      break
    if len(tokens_a) &gt; len(tokens_b):
      tokens_a.pop()
    else:
      tokens_b.pop()


def create_model(bert_config, is_training, input_ids, input_mask, segment_ids,
                 labels, num_labels, use_one_hot_embeddings):
  &quot;&quot;&quot;Creates a classification model.&quot;&quot;&quot;
  model = modeling.BertModel(
      config=bert_config,
      is_training=is_training,
      input_ids=input_ids,
      input_mask=input_mask,
      token_type_ids=segment_ids,
      use_one_hot_embeddings=use_one_hot_embeddings)

  # In the demo, we are doing a simple classification task on the entire
  # segment.
  #
  # If you want to use the token-level output, use model.get_sequence_output()
  # instead.
  output_layer = model.get_pooled_output()

  hidden_size = output_layer.shape[-1]

  output_weights = tf.compat.v1.get_variable(
      &quot;output_weights&quot;, [num_labels, hidden_size],
      initializer=tf.compat.v1.truncated_normal_initializer(stddev=0.02))

  output_bias = tf.compat.v1.get_variable(
      &quot;output_bias&quot;, [num_labels], initializer=tf.zeros_initializer())

  with tf.compat.v1.variable_scope(&quot;loss&quot;):
    if is_training:
      # I.e., 0.1 dropout
      output_layer = tf.compat.v1.nn.dropout(output_layer, keep_prob=0.9)

    logits = tf.matmul(output_layer, output_weights, transpose_b=True)
    logits = tf.nn.bias_add(logits, output_bias)
    probabilities = tf.nn.softmax(logits, axis=-1)
    log_probs = tf.nn.log_softmax(logits, axis=-1)

    one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)

    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)
    loss = tf.reduce_mean(per_example_loss)

    return (loss, per_example_loss, logits, probabilities)


def model_fn_builder(bert_config, num_labels, init_checkpoint, learning_rate,
                     num_train_steps, num_warmup_steps, use_tpu,
                     use_one_hot_embeddings):
  &quot;&quot;&quot;Returns `model_fn` closure for TPUEstimator.&quot;&quot;&quot;

  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument
    &quot;&quot;&quot;The `model_fn` for TPUEstimator.&quot;&quot;&quot;

    tf.compat.v1.logging.info(&quot;*** Features ***&quot;)
    for name in sorted(features.keys()):
      tf.compat.v1.logging.info(&quot;  name = %s, shape = %s&quot; % (name, features[name].shape))

    input_ids = features[&quot;input_ids&quot;]
    input_mask = features[&quot;input_mask&quot;]
    segment_ids = features[&quot;segment_ids&quot;]
    label_ids = features[&quot;label_ids&quot;]
    is_real_example = None
    if &quot;is_real_example&quot; in features:
      is_real_example = tf.cast(features[&quot;is_real_example&quot;], dtype=tf.float32)
    else:
      is_real_example = tf.ones(tf.shape(label_ids), dtype=tf.float32)

    is_training = (mode == tf.estimator.ModeKeys.TRAIN)

    (total_loss, per_example_loss, logits, probabilities) = create_model(
        bert_config, is_training, input_ids, input_mask, segment_ids, label_ids,
        num_labels, use_one_hot_embeddings)

    tvars = tf.compat.v1.trainable_variables()
    initialized_variable_names = &#123;&#125;
    scaffold_fn = None
    if init_checkpoint:
      (assignment_map, initialized_variable_names
      ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)
      if use_tpu:

        def tpu_scaffold():
          tf.compat.v1.train.init_from_checkpoint(init_checkpoint, assignment_map)
          return tf.compat.v1.train.Scaffold()

        scaffold_fn = tpu_scaffold
      else:
        tf.compat.v1.train.init_from_checkpoint(init_checkpoint, assignment_map)

    tf.compat.v1.logging.info(&quot;**** Trainable Variables ****&quot;)
    for var in tvars:
      init_string = &quot;&quot;
      if var.name in initialized_variable_names:
        init_string = &quot;, *INIT_FROM_CKPT*&quot;
      tf.compat.v1.logging.info(&quot;  name = %s, shape = %s%s&quot;, var.name, var.shape,
                      init_string)

    output_spec = None
    if mode == tf.estimator.ModeKeys.TRAIN:

      train_op = optimization.create_optimizer(
          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)

      output_spec = tf.compat.v1.estimator.tpu.TPUEstimatorSpec(
          mode=mode,
          loss=total_loss,
          train_op=train_op,
          scaffold_fn=scaffold_fn)
    elif mode == tf.estimator.ModeKeys.EVAL:

      def metric_fn(per_example_loss, label_ids, logits, is_real_example):
        predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)
        accuracy = tf.compat.v1.metrics.accuracy(
            labels=label_ids, predictions=predictions, weights=is_real_example)
        loss = tf.compat.v1.metrics.mean(values=per_example_loss, weights=is_real_example)
        return &#123;
            &quot;eval_accuracy&quot;: accuracy,
            &quot;eval_loss&quot;: loss,
        &#125;

      eval_metrics = (metric_fn,
                      [per_example_loss, label_ids, logits, is_real_example])
      output_spec = tf.compat.v1.estimator.tpu.TPUEstimatorSpec(
          mode=mode,
          loss=total_loss,
          eval_metrics=eval_metrics,
          scaffold_fn=scaffold_fn)
    else:
      output_spec = tf.compat.v1.estimator.tpu.TPUEstimatorSpec(
          mode=mode,
          predictions=&#123;&quot;probabilities&quot;: probabilities&#125;,
          scaffold_fn=scaffold_fn)
    return output_spec

  return model_fn


# This function is not used by this file but is still used by the Colab and
# people who depend on it.
def input_fn_builder(features, seq_length, is_training, drop_remainder):
  &quot;&quot;&quot;Creates an `input_fn` closure to be passed to TPUEstimator.&quot;&quot;&quot;

  all_input_ids = []
  all_input_mask = []
  all_segment_ids = []
  all_label_ids = []

  for feature in features:
    all_input_ids.append(feature.input_ids)
    all_input_mask.append(feature.input_mask)
    all_segment_ids.append(feature.segment_ids)
    all_label_ids.append(feature.label_id)

  def input_fn(params):
    &quot;&quot;&quot;The actual input function.&quot;&quot;&quot;
    batch_size = params[&quot;batch_size&quot;]

    num_examples = len(features)

    # This is for demo purposes and does NOT scale to large data sets. We do
    # not use Dataset.from_generator() because that uses tf.py_func which is
    # not TPU compatible. The right way to load data is with TFRecordReader.
    d = tf.data.Dataset.from_tensor_slices(&#123;
        &quot;input_ids&quot;:
            tf.constant(
                all_input_ids, shape=[num_examples, seq_length],
                dtype=tf.int32),
        &quot;input_mask&quot;:
            tf.constant(
                all_input_mask,
                shape=[num_examples, seq_length],
                dtype=tf.int32),
        &quot;segment_ids&quot;:
            tf.constant(
                all_segment_ids,
                shape=[num_examples, seq_length],
                dtype=tf.int32),
        &quot;label_ids&quot;:
            tf.constant(all_label_ids, shape=[num_examples], dtype=tf.int32),
    &#125;)

    if is_training:
      d = d.repeat()
      d = d.shuffle(buffer_size=100)

    d = d.batch(batch_size=batch_size, drop_remainder=drop_remainder)
    return d

  return input_fn


# This function is not used by this file but is still used by the Colab and
# people who depend on it.
def convert_examples_to_features(examples, label_list, max_seq_length,
                                 tokenizer):
  &quot;&quot;&quot;Convert a set of `InputExample`s to a list of `InputFeatures`.&quot;&quot;&quot;

  features = []
  for (ex_index, example) in enumerate(examples):
    if ex_index % 10000 == 0:
      tf.compat.v1.logging.info(&quot;Writing example %d of %d&quot; % (ex_index, len(examples)))

    feature = convert_single_example(ex_index, example, label_list,
                                     max_seq_length, tokenizer)

    features.append(feature)
  return features


def serving_input_fn():
    # 保存模型为SaveModel格式
    # 采用最原始的feature方式，输入是feature Tensors。
    # 如果采用build_parsing_serving_input_receiver_fn，则输入是tf.Examples

    label_ids = tf.compat.v1.placeholder(tf.int32, [None, 3], name=&#39;label_ids&#39;)
    input_ids = tf.compat.v1.placeholder(tf.int32, [None, 200], name=&#39;input_ids&#39;)
    input_mask = tf.compat.v1.placeholder(tf.int32, [None, 200], name=&#39;input_mask&#39;)
    segment_ids = tf.compat.v1.placeholder(tf.int32, [None, 200], name=&#39;segment_ids&#39;)
    input_fn = tf.estimator.export.build_raw_serving_input_receiver_fn(&#123;
        &#39;label_ids&#39;: label_ids,
        &#39;input_ids&#39;: input_ids,
        &#39;input_mask&#39;: input_mask,
        &#39;segment_ids&#39;: segment_ids,
    &#125;)()
    return input_fn

def main(_):
  tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.INFO)

  processors = &#123;
      &quot;cola&quot;: ColaProcessor,
      &quot;mnli&quot;: MnliProcessor,
      &quot;mrpc&quot;: MrpcProcessor,
      &quot;xnli&quot;: XnliProcessor,
  &#125;

  tokenization.validate_case_matches_checkpoint(FLAGS.do_lower_case,
                                                FLAGS.init_checkpoint)

  if not FLAGS.do_train and not FLAGS.do_eval and not FLAGS.do_predict:
    raise ValueError(
        &quot;At least one of `do_train`, `do_eval` or `do_predict&#39; must be True.&quot;)

  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)

  if FLAGS.max_seq_length &gt; bert_config.max_position_embeddings:
    raise ValueError(
        &quot;Cannot use sequence length %d because the BERT model &quot;
        &quot;was only trained up to sequence length %d&quot; %
        (FLAGS.max_seq_length, bert_config.max_position_embeddings))

  tf.io.gfile.makedirs(FLAGS.output_dir)
  tf.io.gfile.makedirs(FLAGS.trans_model_dir)

  task_name = FLAGS.task_name.lower()

  if task_name not in processors:
    raise ValueError(&quot;Task not found: %s&quot; % (task_name))

  processor = processors[task_name]()

  label_list = processor.get_labels()

  tokenizer = tokenization.FullTokenizer(
      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)

  tpu_cluster_resolver = None
  if FLAGS.use_tpu and FLAGS.tpu_name:
    tpu_cluster_resolver = tf.distribute.cluster_resolver.TPUClusterResolver(
        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)

  is_per_host = tf.compat.v1.estimator.tpu.InputPipelineConfig.PER_HOST_V2
  run_config = tf.compat.v1.estimator.tpu.RunConfig(
      cluster=tpu_cluster_resolver,
      master=FLAGS.master,
      model_dir=FLAGS.output_dir,
      save_checkpoints_steps=FLAGS.save_checkpoints_steps,
      tpu_config=tf.compat.v1.estimator.tpu.TPUConfig(
          iterations_per_loop=FLAGS.iterations_per_loop,
          num_shards=FLAGS.num_tpu_cores,
          per_host_input_for_training=is_per_host))

  train_examples = None
  num_train_steps = None
  num_warmup_steps = None
  if FLAGS.do_train:
    train_examples = processor.get_train_examples(FLAGS.data_dir)
    num_train_steps = int(
        len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)
    num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)

  model_fn = model_fn_builder(
      bert_config=bert_config,
      num_labels=len(label_list),
      init_checkpoint=FLAGS.init_checkpoint,
      learning_rate=FLAGS.learning_rate,
      num_train_steps=num_train_steps,
      num_warmup_steps=num_warmup_steps,
      use_tpu=FLAGS.use_tpu,
      use_one_hot_embeddings=FLAGS.use_tpu)

  # If TPU is not available, this will fall back to normal Estimator on CPU
  # or GPU.
  estimator = tf.compat.v1.estimator.tpu.TPUEstimator(
      use_tpu=FLAGS.use_tpu,
      model_fn=model_fn,
      config=run_config,
      train_batch_size=FLAGS.train_batch_size,
      eval_batch_size=FLAGS.eval_batch_size,
      predict_batch_size=FLAGS.predict_batch_size)

  if FLAGS.do_train:
    train_file = os.path.join(FLAGS.output_dir, &quot;train.tf_record&quot;)
    file_based_convert_examples_to_features(
        train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file)
    tf.compat.v1.logging.info(&quot;***** Running training *****&quot;)
    tf.compat.v1.logging.info(&quot;  Num examples = %d&quot;, len(train_examples))
    tf.compat.v1.logging.info(&quot;  Batch size = %d&quot;, FLAGS.train_batch_size)
    tf.compat.v1.logging.info(&quot;  Num steps = %d&quot;, num_train_steps)
    train_input_fn = file_based_input_fn_builder(
        input_file=train_file,
        seq_length=FLAGS.max_seq_length,
        is_training=True,
        drop_remainder=True)
    estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)

  if FLAGS.do_eval:
    eval_examples = processor.get_dev_examples(FLAGS.data_dir)
    num_actual_eval_examples = len(eval_examples)
    if FLAGS.use_tpu:
      # TPU requires a fixed batch size for all batches, therefore the number
      # of examples must be a multiple of the batch size, or else examples
      # will get dropped. So we pad with fake examples which are ignored
      # later on. These do NOT count towards the metric (all tf.metrics
      # support a per-instance weight, and these get a weight of 0.0).
      while len(eval_examples) % FLAGS.eval_batch_size != 0:
        eval_examples.append(PaddingInputExample())

    eval_file = os.path.join(FLAGS.output_dir, &quot;eval.tf_record&quot;)
    file_based_convert_examples_to_features(
        eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file)

    tf.compat.v1.logging.info(&quot;***** Running evaluation *****&quot;)
    tf.compat.v1.logging.info(&quot;  Num examples = %d (%d actual, %d padding)&quot;,
                    len(eval_examples), num_actual_eval_examples,
                    len(eval_examples) - num_actual_eval_examples)
    tf.compat.v1.logging.info(&quot;  Batch size = %d&quot;, FLAGS.eval_batch_size)

    # This tells the estimator to run through the entire set.
    eval_steps = None
    # However, if running eval on the TPU, you will need to specify the
    # number of steps.
    if FLAGS.use_tpu:
      assert len(eval_examples) % FLAGS.eval_batch_size == 0
      eval_steps = int(len(eval_examples) // FLAGS.eval_batch_size)

    eval_drop_remainder = True if FLAGS.use_tpu else False
    eval_input_fn = file_based_input_fn_builder(
        input_file=eval_file,
        seq_length=FLAGS.max_seq_length,
        is_training=False,
        drop_remainder=eval_drop_remainder)

    result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)

    # trans_model_dir模型转换后输出目录，将模型转换为saved model
    estimator._export_to_tpu = False
    estimator.export_savedmodel(FLAGS.trans_model_dir, serving_input_fn)

    output_eval_file = os.path.join(FLAGS.output_dir, &quot;eval_results.txt&quot;)
    with tf.io.gfile.GFile(output_eval_file, &quot;w&quot;) as writer:
      tf.compat.v1.logging.info(&quot;***** Eval results *****&quot;)
      for key in sorted(result.keys()):
        tf.compat.v1.logging.info(&quot;  %s = %s&quot;, key, str(result[key]))
        writer.write(&quot;%s = %s\n&quot; % (key, str(result[key])))

  if FLAGS.do_predict:
    predict_examples = processor.get_test_examples(FLAGS.data_dir)
    num_actual_predict_examples = len(predict_examples)
    if FLAGS.use_tpu:
      # TPU requires a fixed batch size for all batches, therefore the number
      # of examples must be a multiple of the batch size, or else examples
      # will get dropped. So we pad with fake examples which are ignored
      # later on.
      while len(predict_examples) % FLAGS.predict_batch_size != 0:
        predict_examples.append(PaddingInputExample())

    predict_file = os.path.join(FLAGS.output_dir, &quot;predict.tf_record&quot;)
    file_based_convert_examples_to_features(predict_examples, label_list,
                                            FLAGS.max_seq_length, tokenizer,
                                            predict_file)

    tf.compat.v1.logging.info(&quot;***** Running prediction*****&quot;)
    tf.compat.v1.logging.info(&quot;  Num examples = %d (%d actual, %d padding)&quot;,
                    len(predict_examples), num_actual_predict_examples,
                    len(predict_examples) - num_actual_predict_examples)
    tf.compat.v1.logging.info(&quot;  Batch size = %d&quot;, FLAGS.predict_batch_size)

    predict_drop_remainder = True if FLAGS.use_tpu else False
    predict_input_fn = file_based_input_fn_builder(
        input_file=predict_file,
        seq_length=FLAGS.max_seq_length,
        is_training=False,
        drop_remainder=predict_drop_remainder)

    result = estimator.predict(input_fn=predict_input_fn)

    output_predict_file = os.path.join(FLAGS.output_dir, &quot;test_results.tsv&quot;)
    with tf.io.gfile.GFile(output_predict_file, &quot;w&quot;) as writer:
      num_written_lines = 0
      tf.compat.v1.logging.info(&quot;***** Predict results *****&quot;)
      for (i, prediction) in enumerate(result):
        probabilities = prediction[&quot;probabilities&quot;]
        if i &gt;= num_actual_predict_examples:
          break
        output_line = &quot;\t&quot;.join(
            str(class_probability)
            for class_probability in probabilities) + &quot;\n&quot;
        writer.write(output_line)
        num_written_lines += 1
    assert num_written_lines == num_actual_predict_examples


if __name__ == &quot;__main__&quot;:
  flags.mark_flag_as_required(&quot;data_dir&quot;)
  flags.mark_flag_as_required(&quot;task_name&quot;)
  flags.mark_flag_as_required(&quot;vocab_file&quot;)
  flags.mark_flag_as_required(&quot;bert_config_file&quot;)
  flags.mark_flag_as_required(&quot;output_dir&quot;)
  flags.mark_flag_as_required(&quot;trans_model_dir&quot;)
  app.run(main)</code></pre>
<h5 id="optimization.py">optimization.py</h5>
<pre class="python3"><code>from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import re
import tensorflow as tf


def create_optimizer(loss, init_lr, num_train_steps, num_warmup_steps, use_tpu):
  &quot;&quot;&quot;Creates an optimizer training op.&quot;&quot;&quot;
  global_step = tf.compat.v1.train.get_or_create_global_step()

  learning_rate = tf.constant(value=init_lr, shape=[], dtype=tf.float32)

  # Implements linear decay of the learning rate.
  learning_rate = tf.compat.v1.train.polynomial_decay(
      learning_rate,
      global_step,
      num_train_steps,
      end_learning_rate=0.0,
      power=1.0,
      cycle=False)

  # Implements linear warmup. I.e., if global_step &lt; num_warmup_steps, the
  # learning rate will be `global_step/num_warmup_steps * init_lr`.
  if num_warmup_steps:
    global_steps_int = tf.cast(global_step, tf.int32)
    warmup_steps_int = tf.constant(num_warmup_steps, dtype=tf.int32)

    global_steps_float = tf.cast(global_steps_int, tf.float32)
    warmup_steps_float = tf.cast(warmup_steps_int, tf.float32)

    warmup_percent_done = global_steps_float / warmup_steps_float
    warmup_learning_rate = init_lr * warmup_percent_done

    is_warmup = tf.cast(global_steps_int &lt; warmup_steps_int, tf.float32)
    learning_rate = (
        (1.0 - is_warmup) * learning_rate + is_warmup * warmup_learning_rate)

  # It is recommended that you use this optimizer for fine tuning, since this
  # is how the model was trained (note that the Adam m/v variables are NOT
  # loaded from init_checkpoint.)
  optimizer = AdamWeightDecayOptimizer(
      learning_rate=learning_rate,
      weight_decay_rate=0.01,
      beta_1=0.9,
      beta_2=0.999,
      epsilon=1e-6,
      exclude_from_weight_decay=[&quot;LayerNorm&quot;, &quot;layer_norm&quot;, &quot;bias&quot;])

  if use_tpu:
    optimizer = tf.compat.v1.estimator.tpu.CrossShardOptimizer(optimizer)

  tvars = tf.compat.v1.trainable_variables()
  grads = tf.gradients(loss, tvars)

  # This is how the model was pre-trained.
  (grads, _) = tf.clip_by_global_norm(grads, clip_norm=1.0)

  train_op = optimizer.apply_gradients(
      zip(grads, tvars), global_step=global_step)

  # Normally the global step update is done inside of `apply_gradients`.
  # However, `AdamWeightDecayOptimizer` doesn&#39;t do this. But if you use
  # a different optimizer, you should probably take this line out.
  new_global_step = global_step + 1
  train_op = tf.group(train_op, [global_step.assign(new_global_step)])
  return train_op


class AdamWeightDecayOptimizer(tf.keras.optimizers.Optimizer):
  &quot;&quot;&quot;A basic Adam optimizer that includes &quot;correct&quot; L2 weight decay.&quot;&quot;&quot;

  def __init__(self,
               learning_rate,
               weight_decay_rate=0.0,
               beta_1=0.9,
               beta_2=0.999,
               epsilon=1e-6,
               exclude_from_weight_decay=None,
               name=&quot;AdamWeightDecayOptimizer&quot;):
    &quot;&quot;&quot;Constructs a AdamWeightDecayOptimizer.&quot;&quot;&quot;
    super(AdamWeightDecayOptimizer, self).__init__(False, name)

    self.learning_rate = learning_rate
    self.weight_decay_rate = weight_decay_rate
    self.beta_1 = beta_1
    self.beta_2 = beta_2
    self.epsilon = epsilon
    self.exclude_from_weight_decay = exclude_from_weight_decay

  def apply_gradients(self, grads_and_vars, global_step=None, name=None):
    &quot;&quot;&quot;See base class.&quot;&quot;&quot;
    assignments = []
    for (grad, param) in grads_and_vars:
      if grad is None or param is None:
        continue

      param_name = self._get_variable_name(param.name)

      m = tf.compat.v1.get_variable(
          name=param_name + &quot;/adam_m&quot;,
          shape=param.shape.as_list(),
          dtype=tf.float32,
          trainable=False,
          initializer=tf.zeros_initializer())
      v = tf.compat.v1.get_variable(
          name=param_name + &quot;/adam_v&quot;,
          shape=param.shape.as_list(),
          dtype=tf.float32,
          trainable=False,
          initializer=tf.zeros_initializer())

      # Standard Adam update.
      next_m = (
          tf.multiply(self.beta_1, m) + tf.multiply(1.0 - self.beta_1, grad))
      next_v = (
          tf.multiply(self.beta_2, v) + tf.multiply(1.0 - self.beta_2,
                                                    tf.square(grad)))

      update = next_m / (tf.sqrt(next_v) + self.epsilon)

      # Just adding the square of the weights to the loss function is *not*
      # the correct way of using L2 regularization/weight decay with Adam,
      # since that will interact with the m and v parameters in strange ways.
      #
      # Instead we want ot decay the weights in a manner that doesn&#39;t interact
      # with the m/v parameters. This is equivalent to adding the square
      # of the weights to the loss with plain (non-momentum) SGD.
      if self._do_use_weight_decay(param_name):
        update += self.weight_decay_rate * param

      update_with_lr = self.learning_rate * update

      next_param = param - update_with_lr

      assignments.extend(
          [param.assign(next_param),
           m.assign(next_m),
           v.assign(next_v)])
    return tf.group(*assignments, name=name)

  def _do_use_weight_decay(self, param_name):
    &quot;&quot;&quot;Whether to use L2 weight decay for `param_name`.&quot;&quot;&quot;
    if not self.weight_decay_rate:
      return False
    if self.exclude_from_weight_decay:
      for r in self.exclude_from_weight_decay:
        if re.search(r, param_name) is not None:
          return False
    return True

  def _get_variable_name(self, param_name):
    &quot;&quot;&quot;Get the variable name from the tensor name.&quot;&quot;&quot;
    m = re.match(&quot;^(.*):\\d+$&quot;, param_name)
    if m is not None:
      param_name = m.group(1)
    return param_name
</code></pre>
<h5 id="tokenization.py">tokenization.py</h5>
<pre class="python3"><code>
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import collections
import re
import unicodedata
import six
import tensorflow as tf


def validate_case_matches_checkpoint(do_lower_case, init_checkpoint):
  &quot;&quot;&quot;Checks whether the casing config is consistent with the checkpoint name.&quot;&quot;&quot;

  # The casing has to be passed in by the user and there is no explicit check
  # as to whether it matches the checkpoint. The casing information probably
  # should have been stored in the bert_config.json file, but it&#39;s not, so
  # we have to heuristically detect it to validate.

  if not init_checkpoint:
    return

  m = re.match(&quot;^.*?([A-Za-z0-9_-]+)/bert_model.ckpt&quot;, init_checkpoint)
  if m is None:
    return

  model_name = m.group(1)

  lower_models = [
      &quot;uncased_L-24_H-1024_A-16&quot;, &quot;uncased_L-12_H-768_A-12&quot;,
      &quot;multilingual_L-12_H-768_A-12&quot;, &quot;chinese_L-12_H-768_A-12&quot;
  ]

  cased_models = [
      &quot;cased_L-12_H-768_A-12&quot;, &quot;cased_L-24_H-1024_A-16&quot;,
      &quot;multi_cased_L-12_H-768_A-12&quot;
  ]

  is_bad_config = False
  if model_name in lower_models and not do_lower_case:
    is_bad_config = True
    actual_flag = &quot;False&quot;
    case_name = &quot;lowercased&quot;
    opposite_flag = &quot;True&quot;

  if model_name in cased_models and do_lower_case:
    is_bad_config = True
    actual_flag = &quot;True&quot;
    case_name = &quot;cased&quot;
    opposite_flag = &quot;False&quot;

  if is_bad_config:
    raise ValueError(
        &quot;You passed in `--do_lower_case=%s` with `--init_checkpoint=%s`. &quot;
        &quot;However, `%s` seems to be a %s model, so you &quot;
        &quot;should pass in `--do_lower_case=%s` so that the fine-tuning matches &quot;
        &quot;how the model was pre-training. If this error is wrong, please &quot;
        &quot;just comment out this check.&quot; % (actual_flag, init_checkpoint,
                                          model_name, case_name, opposite_flag))


def convert_to_unicode(text):
  &quot;&quot;&quot;Converts `text` to Unicode (if it&#39;s not already), assuming utf-8 input.&quot;&quot;&quot;
  if six.PY3:
    if isinstance(text, str):
      return text
    elif isinstance(text, bytes):
      return text.decode(&quot;utf-8&quot;, &quot;ignore&quot;)
    else:
      raise ValueError(&quot;Unsupported string type: %s&quot; % (type(text)))
  elif six.PY2:
    if isinstance(text, str):
      return text.decode(&quot;utf-8&quot;, &quot;ignore&quot;)
    elif isinstance(text, unicode):
      return text
    else:
      raise ValueError(&quot;Unsupported string type: %s&quot; % (type(text)))
  else:
    raise ValueError(&quot;Not running on Python2 or Python 3?&quot;)


def printable_text(text):
  &quot;&quot;&quot;Returns text encoded in a way suitable for print or `tf.logging`.&quot;&quot;&quot;

  # These functions want `str` for both Python2 and Python3, but in one case
  # it&#39;s a Unicode string and in the other it&#39;s a byte string.
  if six.PY3:
    if isinstance(text, str):
      return text
    elif isinstance(text, bytes):
      return text.decode(&quot;utf-8&quot;, &quot;ignore&quot;)
    else:
      raise ValueError(&quot;Unsupported string type: %s&quot; % (type(text)))
  elif six.PY2:
    if isinstance(text, str):
      return text
    elif isinstance(text, unicode):
      return text.encode(&quot;utf-8&quot;)
    else:
      raise ValueError(&quot;Unsupported string type: %s&quot; % (type(text)))
  else:
    raise ValueError(&quot;Not running on Python2 or Python 3?&quot;)


def load_vocab(vocab_file):
  &quot;&quot;&quot;Loads a vocabulary file into a dictionary.&quot;&quot;&quot;
  vocab = collections.OrderedDict()
  index = 0
  with tf.io.gfile.GFile(vocab_file, &quot;r&quot;) as reader:
    while True:
      token = convert_to_unicode(reader.readline())
      if not token:
        break
      token = token.strip()
      vocab[token] = index
      index += 1
  return vocab


def convert_by_vocab(vocab, items):
  &quot;&quot;&quot;Converts a sequence of [tokens|ids] using the vocab.&quot;&quot;&quot;
  output = []
  for item in items:
    output.append(vocab[item])
  return output


def convert_tokens_to_ids(vocab, tokens):
  return convert_by_vocab(vocab, tokens)


def convert_ids_to_tokens(inv_vocab, ids):
  return convert_by_vocab(inv_vocab, ids)


def whitespace_tokenize(text):
  &quot;&quot;&quot;Runs basic whitespace cleaning and splitting on a piece of text.&quot;&quot;&quot;
  text = text.strip()
  if not text:
    return []
  tokens = text.split()
  return tokens


class FullTokenizer(object):
  &quot;&quot;&quot;Runs end-to-end tokenziation.&quot;&quot;&quot;

  def __init__(self, vocab_file, do_lower_case=True):
    self.vocab = load_vocab(vocab_file)
    self.inv_vocab = &#123;v: k for k, v in self.vocab.items()&#125;
    self.basic_tokenizer = BasicTokenizer(do_lower_case=do_lower_case)
    self.wordpiece_tokenizer = WordpieceTokenizer(vocab=self.vocab)

  def tokenize(self, text):
    split_tokens = []
    for token in self.basic_tokenizer.tokenize(text):
      for sub_token in self.wordpiece_tokenizer.tokenize(token):
        split_tokens.append(sub_token)

    return split_tokens

  def convert_tokens_to_ids(self, tokens):
    return convert_by_vocab(self.vocab, tokens)

  def convert_ids_to_tokens(self, ids):
    return convert_by_vocab(self.inv_vocab, ids)


class BasicTokenizer(object):
  &quot;&quot;&quot;Runs basic tokenization (punctuation splitting, lower casing, etc.).&quot;&quot;&quot;

  def __init__(self, do_lower_case=True):
    &quot;&quot;&quot;Constructs a BasicTokenizer.

    Args:
      do_lower_case: Whether to lower case the input.
    &quot;&quot;&quot;
    self.do_lower_case = do_lower_case

  def tokenize(self, text):
    &quot;&quot;&quot;Tokenizes a piece of text.&quot;&quot;&quot;
    text = convert_to_unicode(text)
    text = self._clean_text(text)

    # This was added on November 1st, 2018 for the multilingual and Chinese
    # models. This is also applied to the English models now, but it doesn&#39;t
    # matter since the English models were not trained on any Chinese data
    # and generally don&#39;t have any Chinese data in them (there are Chinese
    # characters in the vocabulary because Wikipedia does have some Chinese
    # words in the English Wikipedia.).
    text = self._tokenize_chinese_chars(text)

    orig_tokens = whitespace_tokenize(text)
    split_tokens = []
    for token in orig_tokens:
      if self.do_lower_case:
        token = token.lower()
        token = self._run_strip_accents(token)
      split_tokens.extend(self._run_split_on_punc(token))

    output_tokens = whitespace_tokenize(&quot; &quot;.join(split_tokens))
    return output_tokens

  def _run_strip_accents(self, text):
    &quot;&quot;&quot;Strips accents from a piece of text.&quot;&quot;&quot;
    text = unicodedata.normalize(&quot;NFD&quot;, text)
    output = []
    for char in text:
      cat = unicodedata.category(char)
      if cat == &quot;Mn&quot;:
        continue
      output.append(char)
    return &quot;&quot;.join(output)

  def _run_split_on_punc(self, text):
    &quot;&quot;&quot;Splits punctuation on a piece of text.&quot;&quot;&quot;
    chars = list(text)
    i = 0
    start_new_word = True
    output = []
    while i &lt; len(chars):
      char = chars[i]
      if _is_punctuation(char):
        output.append([char])
        start_new_word = True
      else:
        if start_new_word:
          output.append([])
        start_new_word = False
        output[-1].append(char)
      i += 1

    return [&quot;&quot;.join(x) for x in output]

  def _tokenize_chinese_chars(self, text):
    &quot;&quot;&quot;Adds whitespace around any CJK character.&quot;&quot;&quot;
    output = []
    for char in text:
      cp = ord(char)
      if self._is_chinese_char(cp):
        output.append(&quot; &quot;)
        output.append(char)
        output.append(&quot; &quot;)
      else:
        output.append(char)
    return &quot;&quot;.join(output)

  def _is_chinese_char(self, cp):
    &quot;&quot;&quot;Checks whether CP is the codepoint of a CJK character.&quot;&quot;&quot;
    # This defines a &quot;chinese character&quot; as anything in the CJK Unicode block:
    #   https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)
    #
    # Note that the CJK Unicode block is NOT all Japanese and Korean characters,
    # despite its name. The modern Korean Hangul alphabet is a different block,
    # as is Japanese Hiragana and Katakana. Those alphabets are used to write
    # space-separated words, so they are not treated specially and handled
    # like the all of the other languages.
    if ((cp &gt;= 0x4E00 and cp &lt;= 0x9FFF) or  #
        (cp &gt;= 0x3400 and cp &lt;= 0x4DBF) or  #
        (cp &gt;= 0x20000 and cp &lt;= 0x2A6DF) or  #
        (cp &gt;= 0x2A700 and cp &lt;= 0x2B73F) or  #
        (cp &gt;= 0x2B740 and cp &lt;= 0x2B81F) or  #
        (cp &gt;= 0x2B820 and cp &lt;= 0x2CEAF) or
        (cp &gt;= 0xF900 and cp &lt;= 0xFAFF) or  #
        (cp &gt;= 0x2F800 and cp &lt;= 0x2FA1F)):  #
      return True

    return False

  def _clean_text(self, text):
    &quot;&quot;&quot;Performs invalid character removal and whitespace cleanup on text.&quot;&quot;&quot;
    output = []
    for char in text:
      cp = ord(char)
      if cp == 0 or cp == 0xfffd or _is_control(char):
        continue
      if _is_whitespace(char):
        output.append(&quot; &quot;)
      else:
        output.append(char)
    return &quot;&quot;.join(output)


class WordpieceTokenizer(object):
  &quot;&quot;&quot;Runs WordPiece tokenziation.&quot;&quot;&quot;

  def __init__(self, vocab, unk_token=&quot;[UNK]&quot;, max_input_chars_per_word=200):
    self.vocab = vocab
    self.unk_token = unk_token
    self.max_input_chars_per_word = max_input_chars_per_word

  def tokenize(self, text):
    &quot;&quot;&quot;Tokenizes a piece of text into its word pieces.

    This uses a greedy longest-match-first algorithm to perform tokenization
    using the given vocabulary.

    For example:
      input = &quot;unaffable&quot;
      output = [&quot;un&quot;, &quot;##aff&quot;, &quot;##able&quot;]

    Args:
      text: A single token or whitespace separated tokens. This should have
        already been passed through `BasicTokenizer.

    Returns:
      A list of wordpiece tokens.
    &quot;&quot;&quot;

    text = convert_to_unicode(text)

    output_tokens = []
    for token in whitespace_tokenize(text):
      chars = list(token)
      if len(chars) &gt; self.max_input_chars_per_word:
        output_tokens.append(self.unk_token)
        continue

      is_bad = False
      start = 0
      sub_tokens = []
      while start &lt; len(chars):
        end = len(chars)
        cur_substr = None
        while start &lt; end:
          substr = &quot;&quot;.join(chars[start:end])
          if start &gt; 0:
            substr = &quot;##&quot; + substr
          if substr in self.vocab:
            cur_substr = substr
            break
          end -= 1
        if cur_substr is None:
          is_bad = True
          break
        sub_tokens.append(cur_substr)
        start = end

      if is_bad:
        output_tokens.append(self.unk_token)
      else:
        output_tokens.extend(sub_tokens)
    return output_tokens


def _is_whitespace(char):
  &quot;&quot;&quot;Checks whether `chars` is a whitespace character.&quot;&quot;&quot;
  # \t, \n, and \r are technically contorl characters but we treat them
  # as whitespace since they are generally considered as such.
  if char == &quot; &quot; or char == &quot;\t&quot; or char == &quot;\n&quot; or char == &quot;\r&quot;:
    return True
  cat = unicodedata.category(char)
  if cat == &quot;Zs&quot;:
    return True
  return False


def _is_control(char):
  &quot;&quot;&quot;Checks whether `chars` is a control character.&quot;&quot;&quot;
  # These are technically control characters but we count them as whitespace
  # characters.
  if char == &quot;\t&quot; or char == &quot;\n&quot; or char == &quot;\r&quot;:
    return False
  cat = unicodedata.category(char)
  if cat in (&quot;Cc&quot;, &quot;Cf&quot;):
    return True
  return False


def _is_punctuation(char):
  &quot;&quot;&quot;Checks whether `chars` is a punctuation character.&quot;&quot;&quot;
  cp = ord(char)
  # We treat all non-letter/number ASCII as punctuation.
  # Characters such as &quot;^&quot;, &quot;$&quot;, and &quot;`&quot; are not in the Unicode
  # Punctuation class but we treat them as punctuation anyways, for
  # consistency.
  if ((cp &gt;= 33 and cp &lt;= 47) or (cp &gt;= 58 and cp &lt;= 64) or
      (cp &gt;= 91 and cp &lt;= 96) or (cp &gt;= 123 and cp &lt;= 126)):
    return True
  cat = unicodedata.category(char)
  if cat.startswith(&quot;P&quot;):
    return True
  return False
</code></pre>
<h5 id="modeling.py">modeling.py</h5>
<pre class="python3"><code>
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import collections
import copy
import json
import math
import re
import numpy as np
import six
import tensorflow as tf


class BertConfig(object):
  &quot;&quot;&quot;Configuration for `BertModel`.&quot;&quot;&quot;

  def __init__(self,
               vocab_size,
               hidden_size=768,
               num_hidden_layers=12,
               num_attention_heads=12,
               intermediate_size=3072,
               hidden_act=&quot;gelu&quot;,
               hidden_dropout_prob=0.1,
               attention_probs_dropout_prob=0.1,
               max_position_embeddings=512,
               type_vocab_size=16,
               initializer_range=0.02):
    &quot;&quot;&quot;Constructs BertConfig.

    Args:
      vocab_size: Vocabulary size of `inputs_ids` in `BertModel`.
      hidden_size: Size of the encoder layers and the pooler layer.
      num_hidden_layers: Number of hidden layers in the Transformer encoder.
      num_attention_heads: Number of attention heads for each attention layer in
        the Transformer encoder.
      intermediate_size: The size of the &quot;intermediate&quot; (i.e., feed-forward)
        layer in the Transformer encoder.
      hidden_act: The non-linear activation function (function or string) in the
        encoder and pooler.
      hidden_dropout_prob: The dropout probability for all fully connected
        layers in the embeddings, encoder, and pooler.
      attention_probs_dropout_prob: The dropout ratio for the attention
        probabilities.
      max_position_embeddings: The maximum sequence length that this model might
        ever be used with. Typically set this to something large just in case
        (e.g., 512 or 1024 or 2048).
      type_vocab_size: The vocabulary size of the `token_type_ids` passed into
        `BertModel`.
      initializer_range: The stdev of the truncated_normal_initializer for
        initializing all weight matrices.
    &quot;&quot;&quot;
    self.vocab_size = vocab_size
    self.hidden_size = hidden_size
    self.num_hidden_layers = num_hidden_layers
    self.num_attention_heads = num_attention_heads
    self.hidden_act = hidden_act
    self.intermediate_size = intermediate_size
    self.hidden_dropout_prob = hidden_dropout_prob
    self.attention_probs_dropout_prob = attention_probs_dropout_prob
    self.max_position_embeddings = max_position_embeddings
    self.type_vocab_size = type_vocab_size
    self.initializer_range = initializer_range

  @classmethod
  def from_dict(cls, json_object):
    &quot;&quot;&quot;Constructs a `BertConfig` from a Python dictionary of parameters.&quot;&quot;&quot;
    config = BertConfig(vocab_size=None)
    for (key, value) in six.iteritems(json_object):
      config.__dict__[key] = value
    return config

  @classmethod
  def from_json_file(cls, json_file):
    &quot;&quot;&quot;Constructs a `BertConfig` from a json file of parameters.&quot;&quot;&quot;
    with tf.io.gfile.GFile(json_file, &quot;r&quot;) as reader:
      text = reader.read()
    return cls.from_dict(json.loads(text))

  def to_dict(self):
    &quot;&quot;&quot;Serializes this instance to a Python dictionary.&quot;&quot;&quot;
    output = copy.deepcopy(self.__dict__)
    return output

  def to_json_string(self):
    &quot;&quot;&quot;Serializes this instance to a JSON string.&quot;&quot;&quot;
    return json.dumps(self.to_dict(), indent=2, sort_keys=True) + &quot;\n&quot;


class BertModel(object):
  &quot;&quot;&quot;BERT model (&quot;Bidirectional Encoder Representations from Transformers&quot;).

  Example usage:

  ```python
  # Already been converted into WordPiece token ids
  input_ids = tf.constant([[31, 51, 99], [15, 5, 0]])
  input_mask = tf.constant([[1, 1, 1], [1, 1, 0]])
  token_type_ids = tf.constant([[0, 0, 1], [0, 2, 0]])

  config = modeling.BertConfig(vocab_size=32000, hidden_size=512,
    num_hidden_layers=8, num_attention_heads=6, intermediate_size=1024)

  model = modeling.BertModel(config=config, is_training=True,
    input_ids=input_ids, input_mask=input_mask, token_type_ids=token_type_ids)

  label_embeddings = tf.compact.v1.get_variable(...)
  pooled_output = model.get_pooled_output()
  logits = tf.matmul(pooled_output, label_embeddings)
  ...</code></pre>
<p>"""</p>
<p>def <strong>init</strong>(self, config, is_training, input_ids,
input_mask=None, token_type_ids=None, use_one_hot_embeddings=False,
scope=None): """Constructor for BertModel.</p>
<pre><code>Args:
  config: `BertConfig` instance.
  is_training: bool. true for training model, false for eval model. Controls
    whether dropout will be applied.
  input_ids: int32 Tensor of shape [batch_size, seq_length].
  input_mask: (optional) int32 Tensor of shape [batch_size, seq_length].
  token_type_ids: (optional) int32 Tensor of shape [batch_size, seq_length].
  use_one_hot_embeddings: (optional) bool. Whether to use one-hot word
    embeddings or tf.embedding_lookup() for the word embeddings.
  scope: (optional) variable scope. Defaults to &quot;bert&quot;.

Raises:
  ValueError: The config is invalid or one of the input tensor shapes
    is invalid.
&quot;&quot;&quot;
config = copy.deepcopy(config)
if not is_training:
  config.hidden_dropout_prob = 0.0
  config.attention_probs_dropout_prob = 0.0

input_shape = get_shape_list(input_ids, expected_rank=2)
batch_size = input_shape[0]
seq_length = input_shape[1]

if input_mask is None:
  input_mask = tf.ones(shape=[batch_size, seq_length], dtype=tf.int32)

if token_type_ids is None:
  token_type_ids = tf.zeros(shape=[batch_size, seq_length], dtype=tf.int32)

with tf.compat.v1.variable_scope(scope, default_name=&quot;bert&quot;):
  with tf.compat.v1.variable_scope(&quot;embeddings&quot;):
    # Perform embedding lookup on the word ids.
    (self.embedding_output, self.embedding_table) = embedding_lookup(
        input_ids=input_ids,
        vocab_size=config.vocab_size,
        embedding_size=config.hidden_size,
        initializer_range=config.initializer_range,
        word_embedding_name=&quot;word_embeddings&quot;,
        use_one_hot_embeddings=use_one_hot_embeddings)

    # Add positional embeddings and token type embeddings, then layer
    # normalize and perform dropout.
    self.embedding_output = embedding_postprocessor(
        input_tensor=self.embedding_output,
        use_token_type=True,
        token_type_ids=token_type_ids,
        token_type_vocab_size=config.type_vocab_size,
        token_type_embedding_name=&quot;token_type_embeddings&quot;,
        use_position_embeddings=True,
        position_embedding_name=&quot;position_embeddings&quot;,
        initializer_range=config.initializer_range,
        max_position_embeddings=config.max_position_embeddings,
        dropout_prob=config.hidden_dropout_prob)

  with tf.compat.v1.variable_scope(&quot;encoder&quot;):
    # This converts a 2D mask of shape [batch_size, seq_length] to a 3D
    # mask of shape [batch_size, seq_length, seq_length] which is used
    # for the attention scores.
    attention_mask = create_attention_mask_from_input_mask(
        input_ids, input_mask)

    # Run the stacked transformer.
    # `sequence_output` shape = [batch_size, seq_length, hidden_size].
    self.all_encoder_layers = transformer_model(
        input_tensor=self.embedding_output,
        attention_mask=attention_mask,
        hidden_size=config.hidden_size,
        num_hidden_layers=config.num_hidden_layers,
        num_attention_heads=config.num_attention_heads,
        intermediate_size=config.intermediate_size,
        intermediate_act_fn=get_activation(config.hidden_act),
        hidden_dropout_prob=config.hidden_dropout_prob,
        attention_probs_dropout_prob=config.attention_probs_dropout_prob,
        initializer_range=config.initializer_range,
        do_return_all_layers=True)

  self.sequence_output = self.all_encoder_layers[-1]
  # The &quot;pooler&quot; converts the encoded sequence tensor of shape
  # [batch_size, seq_length, hidden_size] to a tensor of shape
  # [batch_size, hidden_size]. This is necessary for segment-level
  # (or segment-pair-level) classification tasks where we need a fixed
  # dimensional representation of the segment.
  with tf.compat.v1.variable_scope(&quot;pooler&quot;):
    # We &quot;pool&quot; the model by simply taking the hidden state corresponding
    # to the first token. We assume that this has been pre-trained
    first_token_tensor = tf.squeeze(self.sequence_output[:, 0:1, :], axis=1)
    self.pooled_output = tf.compat.v1.layers.dense(
        first_token_tensor,
        config.hidden_size,
        activation=tf.tanh,
        kernel_initializer=create_initializer(config.initializer_range))</code></pre>
<p>def get_pooled_output(self): return self.pooled_output</p>
<p>def get_sequence_output(self): """Gets final hidden layer of
encoder.</p>
<pre><code>Returns:
  float Tensor of shape [batch_size, seq_length, hidden_size] corresponding
  to the final hidden of the transformer encoder.
&quot;&quot;&quot;
return self.sequence_output</code></pre>
<p>def get_all_encoder_layers(self): return self.all_encoder_layers</p>
<p>def get_embedding_output(self): """Gets output of the embedding
lookup (i.e., input to the transformer).</p>
<pre><code>Returns:
  float Tensor of shape [batch_size, seq_length, hidden_size] corresponding
  to the output of the embedding layer, after summing the word
  embeddings with the positional embeddings and the token type embeddings,
  then performing layer normalization. This is the input to the transformer.
&quot;&quot;&quot;
return self.embedding_output</code></pre>
<p>def get_embedding_table(self): return self.embedding_table</p>
<p>def gelu(x): """Gaussian Error Linear Unit.</p>
<p>This is a smoother version of the RELU. Original paper:
https://arxiv.org/abs/1606.08415 Args: x: float Tensor to perform
activation.</p>
<p>Returns: <code>x</code> with the GELU activation applied. """ cdf =
0.5 * (1.0 + tf.tanh( (np.sqrt(2 / np.pi) * (x + 0.044715 * tf.pow(x,
3))))) return x * cdf</p>
<p>def get_activation(activation_string): """Maps a string to a Python
function, e.g., "relu" =&gt; <code>tf.nn.relu</code>.</p>
<p>Args: activation_string: String name of the activation function.</p>
<p>Returns: A Python function corresponding to the activation function.
If <code>activation_string</code> is None, empty, or "linear", this will
return None. If <code>activation_string</code> is not a string, it will
return <code>activation_string</code>.</p>
<p>Raises: ValueError: The <code>activation_string</code> does not
correspond to a known activation. """</p>
<p># We assume that anything that"s not a string is already an
activation # function, so we just return it. if not
isinstance(activation_string, six.string_types): return
activation_string</p>
<p>if not activation_string: return None</p>
<p>act = activation_string.lower() if act == "linear": return None elif
act == "relu": return tf.nn.relu elif act == "gelu": return gelu elif
act == "tanh": return tf.tanh else: raise ValueError("Unsupported
activation: %s" % act)</p>
<p>def get_assignment_map_from_checkpoint(tvars, init_checkpoint):
"""Compute the union of the current variables and checkpoint
variables.""" assignment_map = {} initialized_variable_names = {}</p>
<p>name_to_variable = collections.OrderedDict() for var in tvars: name =
var.name m = re.match("^(.*):\d+$", name) if m is not None: name =
m.group(1) name_to_variable[name] = var</p>
<p>init_vars = tf.compat.v1.train.list_variables(init_checkpoint)</p>
<p>assignment_map = collections.OrderedDict() for x in init_vars: (name,
var) = (x[0], x[1]) if name not in name_to_variable: continue
assignment_map[name] = name initialized_variable_names[name] = 1
initialized_variable_names[name + ":0"] = 1</p>
<p>return (assignment_map, initialized_variable_names)</p>
<p>def dropout(input_tensor, dropout_prob): """Perform dropout.</p>
<p>Args: input_tensor: float Tensor. dropout_prob: Python float. The
probability of dropping out a value (NOT of <em>keeping</em> a dimension
as in <code>tf.nn.dropout</code>).</p>
<p>Returns: A version of <code>input_tensor</code> with dropout applied.
""" if dropout_prob is None or dropout_prob == 0.0: return
input_tensor</p>
<p>output = tf.nn.dropout(input_tensor, 1.0 - dropout_prob) return
output</p>
<p>def layer_norm(input_tensor, name=None): """Run layer normalization
on the last dimension of the tensor.""" layernorm =
tf.keras.layers.LayerNormalization(axis=-1) return
layernorm(input_tensor)</p>
<p>def layer_norm_and_dropout(input_tensor, dropout_prob, name=None):
"""Runs layer normalization followed by dropout.""" output_tensor =
layer_norm(input_tensor, name) output_tensor = dropout(output_tensor,
dropout_prob) return output_tensor</p>
<p>def create_initializer(initializer_range=0.02): """Creates a
<code>truncated_normal_initializer</code> with the given range."""
return
tf.compat.v1.truncated_normal_initializer(stddev=initializer_range)</p>
<p>def embedding_lookup(input_ids, vocab_size, embedding_size=128,
initializer_range=0.02, word_embedding_name="word_embeddings",
use_one_hot_embeddings=False): """Looks up words embeddings for id
tensor.</p>
<p>Args: input_ids: int32 Tensor of shape [batch_size, seq_length]
containing word ids. vocab_size: int. Size of the embedding vocabulary.
embedding_size: int. Width of the word embeddings. initializer_range:
float. Embedding initialization range. word_embedding_name: string. Name
of the embedding table. use_one_hot_embeddings: bool. If True, use
one-hot method for word embeddings. If False, use
<code>tf.gather()</code>.</p>
<p>Returns: float Tensor of shape [batch_size, seq_length,
embedding_size]. """ # This function assumes that the input is of shape
[batch_size, seq_length, # num_inputs]. # # If the input is a 2D tensor
of shape [batch_size, seq_length], we # reshape to [batch_size,
seq_length, 1]. if input_ids.shape.ndims == 2: input_ids =
tf.expand_dims(input_ids, axis=[-1])</p>
<p>embedding_table = tf.compat.v1.get_variable(
name=word_embedding_name, shape=[vocab_size, embedding_size],
initializer=create_initializer(initializer_range))</p>
<p>flat_input_ids = tf.reshape(input_ids, [-1]) if
use_one_hot_embeddings: one_hot_input_ids = tf.one_hot(flat_input_ids,
depth=vocab_size) output = tf.matmul(one_hot_input_ids, embedding_table)
else: output = tf.gather(embedding_table, flat_input_ids)</p>
<p>input_shape = get_shape_list(input_ids)</p>
<p>output = tf.reshape(output, input_shape[0:-1] + [input_shape[-1] *
embedding_size]) return (output, embedding_table)</p>
<p>def embedding_postprocessor(input_tensor, use_token_type=False,
token_type_ids=None, token_type_vocab_size=16,
token_type_embedding_name="token_type_embeddings",
use_position_embeddings=True,
position_embedding_name="position_embeddings", initializer_range=0.02,
max_position_embeddings=512, dropout_prob=0.1): """Performs various
post-processing on a word embedding tensor.</p>
<p>Args: input_tensor: float Tensor of shape [batch_size, seq_length,
embedding_size]. use_token_type: bool. Whether to add embeddings for
<code>token_type_ids</code>. token_type_ids: (optional) int32 Tensor of
shape [batch_size, seq_length]. Must be specified if
<code>use_token_type</code> is True. token_type_vocab_size: int. The
vocabulary size of <code>token_type_ids</code>.
token_type_embedding_name: string. The name of the embedding table
variable for token type ids. use_position_embeddings: bool. Whether to
add position embeddings for the position of each token in the sequence.
position_embedding_name: string. The name of the embedding table
variable for positional embeddings. initializer_range: float. Range of
the weight initialization. max_position_embeddings: int. Maximum
sequence length that might ever be used with this model. This can be
longer than the sequence length of input_tensor, but cannot be shorter.
dropout_prob: float. Dropout probability applied to the final output
tensor.</p>
<p>Returns: float tensor with same shape as
<code>input_tensor</code>.</p>
<p>Raises: ValueError: One of the tensor shapes or input values is
invalid. """ input_shape = get_shape_list(input_tensor, expected_rank=3)
batch_size = input_shape[0] seq_length = input_shape[1] width =
input_shape[2]</p>
<p>output = input_tensor</p>
<p>if use_token_type: if token_type_ids is None: raise
ValueError("<code>token_type_ids</code> must be specified if"
"<code>use_token_type</code> is True.") token_type_table =
tf.compat.v1.get_variable( name=token_type_embedding_name,
shape=[token_type_vocab_size, width],
initializer=create_initializer(initializer_range)) # This vocab will be
small so we always do one-hot here, since it is always # faster for a
small vocabulary. flat_token_type_ids = tf.reshape(token_type_ids, [-1])
one_hot_ids = tf.one_hot(flat_token_type_ids,
depth=token_type_vocab_size) token_type_embeddings =
tf.matmul(one_hot_ids, token_type_table) token_type_embeddings =
tf.reshape(token_type_embeddings, [batch_size, seq_length, width])
output += token_type_embeddings</p>
<p>if use_position_embeddings: assert_op =
tf.debugging.assert_less_equal(seq_length, max_position_embeddings) with
tf.control_dependencies([assert_op]): full_position_embeddings =
tf.compat.v1.get_variable( name=position_embedding_name,
shape=[max_position_embeddings, width],
initializer=create_initializer(initializer_range)) # Since the position
embedding table is a learned variable, we create it # using a (long)
sequence length <code>max_position_embeddings</code>. The actual #
sequence length might be shorter than this, for faster training of #
tasks that do not have long sequences. # # So
<code>full_position_embeddings</code> is effectively an embedding table
# for position [0, 1, 2, ..., max_position_embeddings-1], and the
current # sequence has positions [0, 1, 2, ... seq_length-1], so we can
just # perform a slice. position_embeddings =
tf.slice(full_position_embeddings, [0, 0], [seq_length, -1]) num_dims =
len(output.shape.as_list())</p>
<pre><code>  # Only the last two dimensions are relevant (`seq_length` and `width`), so
  # we broadcast among the first dimensions, which is typically just
  # the batch size.
  position_broadcast_shape = []
  for _ in range(num_dims - 2):
    position_broadcast_shape.append(1)
  position_broadcast_shape.extend([seq_length, width])
  position_embeddings = tf.reshape(position_embeddings,
                                   position_broadcast_shape)
  output += position_embeddings</code></pre>
<p>output = layer_norm_and_dropout(output, dropout_prob) return
output</p>
<p>def create_attention_mask_from_input_mask(from_tensor, to_mask):
"""Create 3D attention mask from a 2D tensor mask.</p>
<p>Args: from_tensor: 2D or 3D Tensor of shape [batch_size,
from_seq_length, ...]. to_mask: int32 Tensor of shape [batch_size,
to_seq_length].</p>
<p>Returns: float Tensor of shape [batch_size, from_seq_length,
to_seq_length]. """ from_shape = get_shape_list(from_tensor,
expected_rank=[2, 3]) batch_size = from_shape[0] from_seq_length =
from_shape[1]</p>
<p>to_shape = get_shape_list(to_mask, expected_rank=2) to_seq_length =
to_shape[1]</p>
<p>to_mask = tf.cast( tf.reshape(to_mask, [batch_size, 1,
to_seq_length]), tf.float32)</p>
<p># We don't assume that <code>from_tensor</code> is a mask (although
it could be). We # don't actually care if we attend <em>from</em>
padding tokens (only <em>to</em> padding) # tokens so we create a tensor
of all ones. # # <code>broadcast_ones</code> = [batch_size,
from_seq_length, 1] broadcast_ones = tf.ones( shape=[batch_size,
from_seq_length, 1], dtype=tf.float32)</p>
<p># Here we broadcast along two dimensions to create the mask. mask =
broadcast_ones * to_mask</p>
<p>return mask</p>
<p>def attention_layer(from_tensor, to_tensor, attention_mask=None,
num_attention_heads=1, size_per_head=512, query_act=None, key_act=None,
value_act=None, attention_probs_dropout_prob=0.0,
initializer_range=0.02, do_return_2d_tensor=False, batch_size=None,
from_seq_length=None, to_seq_length=None): """Performs multi-headed
attention from <code>from_tensor</code> to <code>to_tensor</code>.</p>
<p>This is an implementation of multi-headed attention based on
"Attention is all you Need". If <code>from_tensor</code> and
<code>to_tensor</code> are the same, then this is self-attention. Each
timestep in <code>from_tensor</code> attends to the corresponding
sequence in <code>to_tensor</code>, and returns a fixed-with vector.</p>
<p>This function first projects <code>from_tensor</code> into a "query"
tensor and <code>to_tensor</code> into "key" and "value" tensors. These
are (effectively) a list of tensors of length
<code>num_attention_heads</code>, where each tensor is of shape
[batch_size, seq_length, size_per_head].</p>
<p>Then, the query and key tensors are dot-producted and scaled. These
are softmaxed to obtain attention probabilities. The value tensors are
then interpolated by these probabilities, then concatenated back to a
single tensor and returned.</p>
<p>In practice, the multi-headed attention are done with transposes and
reshapes rather than actual separate tensors.</p>
<p>Args: from_tensor: float Tensor of shape [batch_size,
from_seq_length, from_width]. to_tensor: float Tensor of shape
[batch_size, to_seq_length, to_width]. attention_mask: (optional) int32
Tensor of shape [batch_size, from_seq_length, to_seq_length]. The values
should be 1 or 0. The attention scores will effectively be set to
-infinity for any positions in the mask that are 0, and will be
unchanged for positions that are 1. num_attention_heads: int. Number of
attention heads. size_per_head: int. Size of each attention head.
query_act: (optional) Activation function for the query transform.
key_act: (optional) Activation function for the key transform.
value_act: (optional) Activation function for the value transform.
attention_probs_dropout_prob: (optional) float. Dropout probability of
the attention probabilities. initializer_range: float. Range of the
weight initializer. do_return_2d_tensor: bool. If True, the output will
be of shape [batch_size * from_seq_length, num_attention_heads *
size_per_head]. If False, the output will be of shape [batch_size,
from_seq_length, num_attention_heads * size_per_head]. batch_size:
(Optional) int. If the input is 2D, this might be the batch size of the
3D version of the <code>from_tensor</code> and <code>to_tensor</code>.
from_seq_length: (Optional) If the input is 2D, this might be the seq
length of the 3D version of the <code>from_tensor</code>. to_seq_length:
(Optional) If the input is 2D, this might be the seq length of the 3D
version of the <code>to_tensor</code>.</p>
<p>Returns: float Tensor of shape [batch_size, from_seq_length,
num_attention_heads * size_per_head]. (If
<code>do_return_2d_tensor</code> is true, this will be of shape
[batch_size * from_seq_length, num_attention_heads *
size_per_head]).</p>
<p>Raises: ValueError: Any of the arguments or tensor shapes are
invalid. """</p>
<p>def transpose_for_scores(input_tensor, batch_size,
num_attention_heads, seq_length, width): output_tensor = tf.reshape(
input_tensor, [batch_size, seq_length, num_attention_heads, width])</p>
<pre><code>output_tensor = tf.transpose(output_tensor, [0, 2, 1, 3])
return output_tensor</code></pre>
<p>from_shape = get_shape_list(from_tensor, expected_rank=[2, 3])
to_shape = get_shape_list(to_tensor, expected_rank=[2, 3])</p>
<p>if len(from_shape) != len(to_shape): raise ValueError( "The rank of
<code>from_tensor</code> must match the rank of
<code>to_tensor</code>.")</p>
<p>if len(from_shape) == 3: batch_size = from_shape[0] from_seq_length =
from_shape[1] to_seq_length = to_shape[1] elif len(from_shape) == 2: if
(batch_size is None or from_seq_length is None or to_seq_length is
None): raise ValueError( "When passing in rank 2 tensors to
attention_layer, the values " "for <code>batch_size</code>,
<code>from_seq_length</code>, and <code>to_seq_length</code> " "must all
be specified.")</p>
<p># Scalar dimensions referenced here: # B = batch size (number of
sequences) # F = <code>from_tensor</code> sequence length # T =
<code>to_tensor</code> sequence length # N =
<code>num_attention_heads</code> # H = <code>size_per_head</code></p>
<p>from_tensor_2d = reshape_to_matrix(from_tensor) to_tensor_2d =
reshape_to_matrix(to_tensor)</p>
<p># <code>query_layer</code> = [B<em>F, N</em>H] query_layer =
tf.compat.v1.layers.dense( from_tensor_2d, num_attention_heads *
size_per_head, activation=query_act, name="query",
kernel_initializer=create_initializer(initializer_range))</p>
<p># <code>key_layer</code> = [B<em>T, N</em>H] key_layer =
tf.compat.v1.layers.dense( to_tensor_2d, num_attention_heads *
size_per_head, activation=key_act, name="key",
kernel_initializer=create_initializer(initializer_range))</p>
<p># <code>value_layer</code> = [B<em>T, N</em>H] value_layer =
tf.compat.v1.layers.dense( to_tensor_2d, num_attention_heads *
size_per_head, activation=value_act, name="value",
kernel_initializer=create_initializer(initializer_range))</p>
<p># <code>query_layer</code> = [B, N, F, H] query_layer =
transpose_for_scores(query_layer, batch_size, num_attention_heads,
from_seq_length, size_per_head)</p>
<p># <code>key_layer</code> = [B, N, T, H] key_layer =
transpose_for_scores(key_layer, batch_size, num_attention_heads,
to_seq_length, size_per_head)</p>
<p># Take the dot product between "query" and "key" to get the raw #
attention scores. # <code>attention_scores</code> = [B, N, F, T]
attention_scores = tf.matmul(query_layer, key_layer, transpose_b=True)
attention_scores = tf.multiply(attention_scores, 1.0 /
math.sqrt(float(size_per_head)))</p>
<p>if attention_mask is not None: # <code>attention_mask</code> = [B, 1,
F, T] attention_mask = tf.expand_dims(attention_mask, axis=[1])</p>
<pre><code># Since attention_mask is 1.0 for positions we want to attend and 0.0 for
# masked positions, this operation will create a tensor which is 0.0 for
# positions we want to attend and -10000.0 for masked positions.
adder = (1.0 - tf.cast(attention_mask, tf.float32)) * -10000.0

# Since we are adding it to the raw scores before the softmax, this is
# effectively the same as removing these entirely.
attention_scores += adder</code></pre>
<p># Normalize the attention scores to probabilities. #
<code>attention_probs</code> = [B, N, F, T] attention_probs =
tf.nn.softmax(attention_scores)</p>
<p># This is actually dropping out entire tokens to attend to, which
might # seem a bit unusual, but is taken from the original Transformer
paper. attention_probs = dropout(attention_probs,
attention_probs_dropout_prob)</p>
<p># <code>value_layer</code> = [B, T, N, H] value_layer = tf.reshape(
value_layer, [batch_size, to_seq_length, num_attention_heads,
size_per_head])</p>
<p># <code>value_layer</code> = [B, N, T, H] value_layer =
tf.transpose(value_layer, [0, 2, 1, 3])</p>
<p># <code>context_layer</code> = [B, N, F, H] context_layer =
tf.matmul(attention_probs, value_layer)</p>
<p># <code>context_layer</code> = [B, F, N, H] context_layer =
tf.transpose(context_layer, [0, 2, 1, 3])</p>
<p>if do_return_2d_tensor: # <code>context_layer</code> = [B<em>F,
N</em>H] context_layer = tf.reshape( context_layer, [batch_size *
from_seq_length, num_attention_heads * size_per_head]) else: #
<code>context_layer</code> = [B, F, N*H] context_layer = tf.reshape(
context_layer, [batch_size, from_seq_length, num_attention_heads *
size_per_head])</p>
<p>return context_layer</p>
<p>def transformer_model(input_tensor, attention_mask=None,
hidden_size=768, num_hidden_layers=12, num_attention_heads=12,
intermediate_size=3072, intermediate_act_fn=gelu,
hidden_dropout_prob=0.1, attention_probs_dropout_prob=0.1,
initializer_range=0.02, do_return_all_layers=False): """Multi-headed,
multi-layer Transformer from "Attention is All You Need".</p>
<p>This is almost an exact implementation of the original Transformer
encoder.</p>
<p>See the original paper: https://arxiv.org/abs/1706.03762</p>
<p>Also see:
https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/models/transformer.py</p>
<p>Args: input_tensor: float Tensor of shape [batch_size, seq_length,
hidden_size]. attention_mask: (optional) int32 Tensor of shape
[batch_size, seq_length, seq_length], with 1 for positions that can be
attended to and 0 in positions that should not be. hidden_size: int.
Hidden size of the Transformer. num_hidden_layers: int. Number of layers
(blocks) in the Transformer. num_attention_heads: int. Number of
attention heads in the Transformer. intermediate_size: int. The size of
the "intermediate" (a.k.a., feed forward) layer. intermediate_act_fn:
function. The non-linear activation function to apply to the output of
the intermediate/feed-forward layer. hidden_dropout_prob: float. Dropout
probability for the hidden layers. attention_probs_dropout_prob: float.
Dropout probability of the attention probabilities. initializer_range:
float. Range of the initializer (stddev of truncated normal).
do_return_all_layers: Whether to also return all layers or just the
final layer.</p>
<p>Returns: float Tensor of shape [batch_size, seq_length, hidden_size],
the final hidden layer of the Transformer.</p>
<p>Raises: ValueError: A Tensor shape or parameter is invalid. """ if
hidden_size % num_attention_heads != 0: raise ValueError( "The hidden
size (%d) is not a multiple of the number of attention " "heads (%d)" %
(hidden_size, num_attention_heads))</p>
<p>attention_head_size = int(hidden_size / num_attention_heads)
input_shape = get_shape_list(input_tensor, expected_rank=3) batch_size =
input_shape[0] seq_length = input_shape[1] input_width =
input_shape[2]</p>
<p># The Transformer performs sum residuals on all layers so the input
needs # to be the same as the hidden size. if input_width !=
hidden_size: raise ValueError("The width of the input tensor (%d) !=
hidden size (%d)" % (input_width, hidden_size))</p>
<p># We keep the representation as a 2D tensor to avoid re-shaping it
back and # forth from a 3D tensor to a 2D tensor. Re-shapes are normally
free on # the GPU/CPU but may not be free on the TPU, so we want to
minimize them to # help the optimizer. prev_output =
reshape_to_matrix(input_tensor)</p>
<p>all_layer_outputs = [] for layer_idx in range(num_hidden_layers):
with tf.compat.v1.variable_scope("layer_%d" % layer_idx): layer_input =
prev_output</p>
<pre><code>  with tf.compat.v1.variable_scope(&quot;attention&quot;):
    attention_heads = []
    with tf.compat.v1.variable_scope(&quot;self&quot;):
      attention_head = attention_layer(
          from_tensor=layer_input,
          to_tensor=layer_input,
          attention_mask=attention_mask,
          num_attention_heads=num_attention_heads,
          size_per_head=attention_head_size,
          attention_probs_dropout_prob=attention_probs_dropout_prob,
          initializer_range=initializer_range,
          do_return_2d_tensor=True,
          batch_size=batch_size,
          from_seq_length=seq_length,
          to_seq_length=seq_length)
      attention_heads.append(attention_head)

    attention_output = None
    if len(attention_heads) == 1:
      attention_output = attention_heads[0]
    else:
      # In the case where we have other sequences, we just concatenate
      # them to the self-attention head before the projection.
      attention_output = tf.concat(attention_heads, axis=-1)

    # Run a linear projection of `hidden_size` then add a residual
    # with `layer_input`.
    with tf.compat.v1.variable_scope(&quot;output&quot;):
      attention_output = tf.compat.v1.layers.dense(
          attention_output,
          hidden_size,
          kernel_initializer=create_initializer(initializer_range))
      attention_output = dropout(attention_output, hidden_dropout_prob)
      attention_output = layer_norm(attention_output + layer_input)

  # The activation is only applied to the &quot;intermediate&quot; hidden layer.
  with tf.compat.v1.variable_scope(&quot;intermediate&quot;):
    intermediate_output = tf.compat.v1.layers.dense(
        attention_output,
        intermediate_size,
        activation=intermediate_act_fn,
        kernel_initializer=create_initializer(initializer_range))

  # Down-project back to `hidden_size` then add the residual.
  with tf.compat.v1.variable_scope(&quot;output&quot;):
    layer_output = tf.compat.v1.layers.dense(
        intermediate_output,
        hidden_size,
        kernel_initializer=create_initializer(initializer_range))
    layer_output = dropout(layer_output, hidden_dropout_prob)
    layer_output = layer_norm(layer_output + attention_output)
    prev_output = layer_output
    all_layer_outputs.append(layer_output)</code></pre>
<p>if do_return_all_layers: final_outputs = [] for layer_output in
all_layer_outputs: final_output = reshape_from_matrix(layer_output,
input_shape) final_outputs.append(final_output) return final_outputs
else: final_output = reshape_from_matrix(prev_output, input_shape)
return final_output</p>
<p>def get_shape_list(tensor, expected_rank=None, name=None): """Returns
a list of the shape of tensor, preferring static dimensions.</p>
<p>Args: tensor: A tf.Tensor object to find the shape of. expected_rank:
(optional) int. The expected rank of <code>tensor</code>. If this is
specified and the <code>tensor</code> has a different rank, and
exception will be thrown. name: Optional name of the tensor for the
error message.</p>
<p>Returns: A list of dimensions of the shape of tensor. All static
dimensions will be returned as python integers, and dynamic dimensions
will be returned as tf.Tensor scalars. """ if name is None: name =
tensor.name</p>
<p>if expected_rank is not None: assert_rank(tensor, expected_rank,
name)</p>
<p>shape = tensor.shape.as_list()</p>
<p>non_static_indexes = [] for (index, dim) in enumerate(shape): if dim
is None: non_static_indexes.append(index)</p>
<p>if not non_static_indexes: return shape</p>
<p>dyn_shape = tf.shape(tensor) for index in non_static_indexes:
shape[index] = dyn_shape[index] return shape</p>
<p>def reshape_to_matrix(input_tensor): """Reshapes a &gt;= rank 2
tensor to a rank 2 tensor (i.e., a matrix).""" ndims =
input_tensor.shape.ndims if ndims &lt; 2: raise ValueError("Input tensor
must have at least rank 2. Shape = %s" % (input_tensor.shape)) if ndims
== 2: return input_tensor</p>
<p>width = input_tensor.shape[-1] output_tensor =
tf.reshape(input_tensor, [-1, width]) return output_tensor</p>
<p>def reshape_from_matrix(output_tensor, orig_shape_list): """Reshapes
a rank 2 tensor back to its original rank &gt;= 2 tensor.""" if
len(orig_shape_list) == 2: return output_tensor</p>
<p>output_shape = get_shape_list(output_tensor)</p>
<p>orig_dims = orig_shape_list[0:-1] width = output_shape[-1]</p>
<p>return tf.reshape(output_tensor, orig_dims + [width])</p>
<p>def assert_rank(tensor, expected_rank, name=None): """Raises an
exception if the tensor rank is not of the expected rank.</p>
<p>Args: tensor: A tf.Tensor to check the rank of. expected_rank: Python
integer or list of integers, expected rank. name: Optional name of the
tensor for the error message.</p>
<p>Raises: ValueError: If the expected shape doesn't match the actual
shape. """ if name is None: name = tensor.name</p>
<p>expected_rank_dict = {} if isinstance(expected_rank,
six.integer_types): expected_rank_dict[expected_rank] = True else: for x
in expected_rank: expected_rank_dict[x] = True</p>
<p>actual_rank = tensor.shape.ndims if actual_rank not in
expected_rank_dict: scope_name = tf.compat.v1.get_variable_scope().name
raise ValueError( "For the tensor <code>%s</code> in scope
<code>%s</code>, the actual rank " "<code>%d</code> (shape = %s) is not
equal to the expected rank <code>%s</code>" % (name, scope_name,
actual_rank, str(tensor.shape), str(expected_rank)))</p>
<p>```</p>
<hr>
<h3 id="about-me">About ME</h3>
<h5 id="读书城南-在未来面前我们都是孩子">👋 读书城南，🤔
在未来面前，我们都是孩子～</h5>
<ul>
<li>📙
一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~</li>
</ul>
<h5 id="social-media">👋 Social Media</h5>
<ul>
<li><p>🛠️ Blog: <a target="_blank" rel="noopener" href="http://oceaneyes.top">http://oceaneyes.top</a></p></li>
<li><p>⚡ PM导航: <a target="_blank" rel="noopener" href="https://pmhub.oceangzy.top">https://pmhub.oceangzy.top</a></p></li>
<li><p>☘️ CNBLOG: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/oceaneyes-gzy/">https://www.cnblogs.com/oceaneyes-gzy/</a></p></li>
<li><p>🌱 AI PRJ自己部署的一些算法demo: <a target="_blank" rel="noopener" href="http://ai.oceangzy.top/">http://ai.oceangzy.top/</a></p></li>
<li><p>📫 Email: 1450136519@qq.com</p></li>
<li><p>💬 WeChat: <a target="_blank" rel="noopener" href="https://oceaneyes.top/img/wechatqrcode.jpg">OCEANGZY</a></p></li>
<li><p>💬 公众号: <a target="_blank" rel="noopener" href="https://oceaneyes.top/img/wechatgzh.jpeg">UncleJoker-GZY</a></p></li>
</ul>
<h5 id="加入小组">👋 加入小组~</h5>
<p><img src="https://oceaneyes.top/img/zhishigroup.jpg" title="加入组织" alt width="240"></p>
<h5 id="感谢打赏">👋 感谢打赏~</h5>
<p><img src="https://oceaneyes.top/img/alipay.jpg" title="支付宝打赏" alt width="140">
<img src="https://oceaneyes.top/img/wechatpay.jpg" title="微信打赏" alt width="140"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://oceangzy.top">OCEAN.GZY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://oceangzy.top/2021/08/01/bert-tf2-6/">http://oceangzy.top/2021/08/01/bert-tf2-6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://oceangzy.top" target="_blank">OCAEN.GZY读书城南</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Artificial-Intelligence/">Artificial Intelligence</a><a class="post-meta__tags" href="/tags/Bert/">Bert</a><a class="post-meta__tags" href="/tags/Natural-Language-Processing/">Natural Language Processing</a><a class="post-meta__tags" href="/tags/Tensorflow-2-6/">Tensorflow 2.6</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/19/pytorch%E5%9B%BE%E5%83%8F%E5%8E%BB%E6%A8%A1%E7%B3%8A/" title="基于PyTorch实现图像去模糊-学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">基于PyTorch实现图像去模糊-学习</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/17/%E5%9F%BA%E4%BA%8ELSTM-CRF%E7%9A%84%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB/" title="基于LSTM+CRF的中文命名实体识别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">基于LSTM+CRF的中文命名实体识别</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/03/01/%E6%90%AD%E5%BB%BA%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" title="搭建自然语言处理的开发环境"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-03-01</div><div class="title">搭建自然语言处理的开发环境</div></div></a></div><div><a href="/2019/03/01/%E6%A1%88%E4%BE%8B-NLP%E5%AE%9E%E7%8E%B0%E9%A2%84%E6%B5%8B%E5%A4%A9%E6%B0%94%E5%86%B7%E6%9A%96%E6%84%9F%E7%9F%A5%E5%BA%A6/" title="案例-NLP实现预测天气冷暖感知度"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-03-01</div><div class="title">案例-NLP实现预测天气冷暖感知度</div></div></a></div><div><a href="/2019/03/01/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E6%A6%82%E8%BF%B0/" title="自然语言处理概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-03-01</div><div class="title">自然语言处理概述</div></div></a></div><div><a href="/2020/12/25/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E9%BB%98%E5%86%99/" title="自然语言的几个重要模型-学习记录"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-25</div><div class="title">自然语言的几个重要模型-学习记录</div></div></a></div><div><a href="/2018/11/26/AI%E6%95%B0%E6%8D%AE%E6%A0%87%E6%B3%A8%E6%98%AF%E4%BB%80%E4%B9%88/" title="AI数据标注是什么"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-11-26</div><div class="title">AI数据标注是什么</div></div></a></div><div><a href="/2019/02/25/AI%E6%97%B6%E4%BB%A3%E5%86%B3%E7%AD%96%E6%95%88%E7%8E%87%E9%9D%A9%E5%91%BD/" title="AI时代决策效率革命"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-25</div><div class="title">AI时代决策效率革命</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">OCEAN.GZY</div><div class="author-info__description">少长聚嬉戏，不殊同队鱼。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">167</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">116</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">94</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/oceangzy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/oceangzy" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/1450136519@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#bert-tf-2.6%E4%BF%AE%E6%94%B9-%E8%87%AA%E8%B0%83%E9%80%82%E9%85%8D%E7%89%88"><span class="toc-number">1.</span> <span class="toc-text">Bert-TF-2.6修改-自调适配版</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#run_classifier.py"><span class="toc-number">1.0.0.2.1.</span> <span class="toc-text">run_classifier.py</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#optimization.py"><span class="toc-number">1.0.0.2.2.</span> <span class="toc-text">optimization.py</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tokenization.py"><span class="toc-number">1.0.0.2.3.</span> <span class="toc-text">tokenization.py</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#modeling.py"><span class="toc-number">1.0.0.2.4.</span> <span class="toc-text">modeling.py</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#about-me"><span class="toc-number">1.0.1.</span> <span class="toc-text">About ME</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E4%B9%A6%E5%9F%8E%E5%8D%97-%E5%9C%A8%E6%9C%AA%E6%9D%A5%E9%9D%A2%E5%89%8D%E6%88%91%E4%BB%AC%E9%83%BD%E6%98%AF%E5%AD%A9%E5%AD%90"><span class="toc-number">1.0.1.0.1.</span> <span class="toc-text">👋 读书城南，🤔
在未来面前，我们都是孩子～</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#social-media"><span class="toc-number">1.0.1.0.2.</span> <span class="toc-text">👋 Social Media</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E5%85%A5%E5%B0%8F%E7%BB%84"><span class="toc-number">1.0.1.0.3.</span> <span class="toc-text">👋 加入小组~</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%84%9F%E8%B0%A2%E6%89%93%E8%B5%8F"><span class="toc-number">1.0.1.0.4.</span> <span class="toc-text">👋 感谢打赏~</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/01/PromptFramework/" title="一些好用的prompt框架">一些好用的prompt框架</a><time datetime="2023-06-01T03:24:15.000Z" title="发表于 2023-06-01 11:24:15">2023-06-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/04/AI%E4%BA%A7%E5%93%81%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84ChatGPT/" title="AI产品视角下的ChatGPT">AI产品视角下的ChatGPT</a><time datetime="2023-03-04T14:58:39.000Z" title="发表于 2023-03-04 22:58:39">2023-03-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/06/01/python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="Python设计模式-六大设计原则">Python设计模式-六大设计原则</a><time datetime="2022-06-01T15:50:00.000Z" title="发表于 2022-06-01 23:50:00">2022-06-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/06/01/python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/" title="Python设计模式-结构型">Python设计模式-结构型</a><time datetime="2022-06-01T15:33:00.000Z" title="发表于 2022-06-01 23:33:00">2022-06-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/06/01/python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/" title="Python设计模式-行为型">Python设计模式-行为型</a><time datetime="2022-06-01T15:31:00.000Z" title="发表于 2022-06-01 23:31:00">2022-06-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/background.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2012 - 2024 By OCEAN.GZY</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>